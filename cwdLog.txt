Sending whole directory to the server...
Files ready...
Streaming:  README.md
EOF file reached, nothing more to read
Total packets to send to server: 4

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 # yogit

The main intention of yogit was for two things:
1. Learn Golang 
2. While learning Go, to build something.
3. Git. Why Git? I use it almost everyday, might as well try and actually understand its inner workings.

This is was pratically doubling two things at the same time: Learing Golang and rebuiling Git. The previous project can be found at [ git_project](https://github.com/persona-mp3/git_project.git). There I explain major innerworkings of how Git works like is Data structure using a Directed Acyclic Graph, zlib compression, concepts of pointers and branches, basically like a time machine. I also made used of visual diagrams to actually make the learning nice

But this is a practical version for the whole project, although the scope has changed to help people understand Git better and the commandline better, this is where I will stop for now.

# Installation
``` bash 
git clone https://github.com/persona-mp3/yogit.git
cd yogit
```

This will clone thewhole repository into your current working fol 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 1, Expecting-tag: 2, Received: 1
server response: 
 b'Packet-Status \r\n1 \r\n200 \r\n1 \r\n2 \r\n'
packet-sync: 0
Current Chunk to send: 
 der and you change youir current directory to yogit

You will see this script called *setup.sh*. If using any vim emulator you can use it to edit or take a look at the code

``` bash
userName@users ~/yogit $ bash setup.sh
```

That will set up yogit to be globally available on your system. To check it run this 

``` bash 
yogit
 ->  WELCOME TO YOGIT
``` 

To see how it works you can go into any test folder of your choice and run basic git commands and it works exactly the same. The logs are left intentionally to make the user aware of whats going on instead of looking at Git like a complex tool, although it is, its simple too, with the right understanding.

### side note -> You can configure the commandline arguments to suit your interests and it won't affect anything inside the main.go file

```bash
yogit init

// this creates a .yogit folder in the current working directory just like .git
``` 

![Alt text](./docs/image-2.png)

### See main.go for basic commands,

            yogit add . -> git add .
        





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 2, Expecting-tag: 3, Received: 2
server response: 
 b'Packet-Status \r\n2 \r\n200 \r\n2 \r\n3 \r\n'
packet-sync: 1
Current Chunk to send: 
      yogit save "" -> git commit -m ""
            yogit ntimeline "" -> git checkout -b "branch_name"
            yogit traveto "" -> git checkout "commit_id"
            yogit switchto "" -> git checkout [branch_name]



# yogit instructions


```bash
yogit add .
```

This basically adds all files in the current directory to staging area just like how git does


```bash
yogit save "message goes in here" 
``` 

To save a commit, just like ```git commit -m "inital commit"``` 
![Alt text](./docs/image-5.png)




### Other features 
1. Checkout
2. Switching branches
3. Logging
<br>

# FUTURE IMPROVEMENTS

As stated with scope above, as most people are new to the command line like I am, I also plan on adding a nice terminal user interface, as seen below

![Alt text](./docs/image-6.png)

Other major integrations that I would like to include is actually helping with the merge conflicts as most people said its hard to understand.



# CONTRIBUTING

### Clone the repo
Make sure you have the go compiler installed at  





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 3, Expecting-tag: 4, Received: 3
server response: 
 b'Packet-Status \r\n3 \r\n200 \r\n3 \r\n4 \r\n'
packet-sync: 2
Current Chunk to send: 
 their offical [website](https://go.dev/doc/install)
```bash
git clone https://github.com/persona-mp3/yogit.git
cd yogit
```

### Run the project
```bash
go run main.go 

# you can refer to the instructions as regular command line args or set it up globally
# go run main.go init 
# go run main.go init 
```

### New updates
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 3
 === All packets sent, closing connection ===
Streaming:  main.go
EOF file reached, nothing more to read
Total packets to send to server: 2

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 package main 

import (
	"fmt"	
	"os"
	"yogit/yogit"
)

func ReadCommandLine(args []string) {
	cmds := len(args)

	if cmds <= 1 {
		yogit.YoGit()
		// fmt.Println("Print instruction manual or enter interactive mode?")
		return
	}

	switch {

	case cmds == 2: {
		if args[1] == "init" {
			yogit.Init()
			return
		}

		// if args[1] == "logs" {
		// 	yogit.Init()
		// 	return
		// }
		
		if args[1] == "clogs" {
			yogit.CheckLogs()
			return
		}
		return
	}

	case cmds == 3: {
		// fmt.Println("command line args has two arguments passed in")
		if args[1] == "save" && args[2] != "" {
			yogit.SaveCommit(args[2])
			return
		}

		if args[1] == "add" && args[2] != "" {
			// yogit.Add(args[2])
			yogit.StagingArea()
			return
		}

		if args[1] == "ntimeline" && args[2] != "" {
			yogit.NewTimeLine(args[2])
		}

		if args[1] == "travelto" && args[2] != "" {
			yogit.TravelTo(args[2])
		}

		if args[1] == "switchto" && args[2] != "" {
			yogit.SwitchTo(args[2])
		}
		
		return
	}

	default  :
		fmt.Println("idk what 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 1, Expecting-tag: 2, Received: 1
server response: 
 b'Packet-Status \r\n1 \r\n200 \r\n1 \r\n2 \r\n'
packet-sync: 0
Current Chunk to send: 
  this guy entered -> ", cmds)
		return
	}

}

func main() {
	
	ReadCommandLine(os.Args)
}
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 1
 === All packets sent, closing connection ===
Streaming:  cwdLog.txt
EOF file reached, nothing more to read
Total packets to send to server: 0

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

 === All packets sent, closing connection ===
Streaming:  install.sh
EOF file reached, nothing more to read
Total packets to send to server: 1

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 #!/usr/bin/bash

echo "Installing and configuring Yogit" 
echo "Building executable..."
$(go build main.go)

windows="main.exe"
linux="main"

if [ -f "$linux" ]; then
  echo "Building for linux systems..."
  BuildLinux
else 
  echo "Building for windows system"
  curr_dir=pwd
  exec_path=$curr_dir/$linux
  echo "fatal: Build failed, please refer to docs at https://github.com/persona-mp3/yogit.git"
  echo "You can directly install the build from the repo"
fi


BuildLinux(){
  echo "Building execution Path"
  curr_dir=pwd
  exec_path=$curr_dir/$linux

  echo "Writing to bashrc..."
  config="alias yogit=$exec_path"
  echo $config

  echo $config >> ~/.bashrc
  echo "--- Confirm config was successful"
  echo "Run `yogit` to confirm or check .bashrc for $config"
}

 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 0
 === All packets sent, closing connection ===
Streaming:  .gitignore
EOF file reached, nothing more to read
Total packets to send to server: 1

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 todo
server.ts 
.yogit
change
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 0
 === All packets sent, closing connection ===
Streaming:  go.sum
EOF file reached, nothing more to read
Total packets to send to server: 2

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 github.com/aquasecurity/table v1.10.0 h1:gPWV28qp9XSlvXdT3ku8yKQoZE6II0vsmegKpW+dB08=
github.com/aquasecurity/table v1.10.0/go.mod h1:eqOmvjjB7AhXFgFqpJUEE/ietg7RrMSJZXyTN8E/wZw=
github.com/liamg/tml v0.7.0 h1:0cVok661KuQy659aFpXpem8mXUDroREuWc1p/+y7hfU=
github.com/liamg/tml v0.7.0/go.mod h1:Vuzs4Dn44Awoyd0MLl2EuJR++l1NlFqU6BJk0oxVYX4=
github.com/mattn/go-runewidth v0.0.13 h1:lTGmDsbAYt5DmK6OnoV7EuIF1wEIFAcxld6ypU4OSgU=
github.com/mattn/go-runewidth v0.0.13/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/rivo/uniseg v0.2.0 h1:S1pD9weZBuJdFmowNwbpi7BJ8TNftyUImj/0WQi72jY=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1 h1:SrN+KX8Art/Sf4HNj6Zcz06G7VEz+7w9tdXTPOZ7+l4=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/term v0.0.0-20220526004731-065cf7ba2467 h1:CBpWXWQpIRjzmkkA+M7q9Fqnwd2mZr3AFqexg8YTfoM=
golang.org/x/term v0.0.0-20220526004 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 1, Expecting-tag: 2, Received: 1
server response: 
 b'Packet-Status \r\n1 \r\n200 \r\n1 \r\n2 \r\n'
packet-sync: 0
Current Chunk to send: 
 731-065cf7ba2467/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 1
 === All packets sent, closing connection ===
Streaming:  go.mod
EOF file reached, nothing more to read
Total packets to send to server: 1

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 module yogit

go 1.24.3

require (
	github.com/aquasecurity/table v1.10.0 // indirect
	github.com/liamg/tml v0.7.0 // indirect
	github.com/mattn/go-runewidth v0.0.13 // indirect
	github.com/rivo/uniseg v0.2.0 // indirect
	golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1 // indirect
	golang.org/x/term v0.0.0-20220526004731-065cf7ba2467 // indirect
)
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 0
 === All packets sent, closing connection ===
Streaming:  yogit/yogit.go
EOF file reached, nothing more to read
Total packets to send to server: 15

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 package yogit

import (
	// "compress/gzip"
	"bufio"
	"bytes"
	"crypto/sha1"
	"encoding/hex"
	"fmt"
	"io"
	"log"
	"os"
	"strings"
	"time"

	"github.com/aquasecurity/table"
	"github.com/liamg/tml"
	// "github.com/liamg/tml"
)

type Commit struct {
	Parent Sha1Hash `json:"parent"`
	Id Sha1Hash `json:"hashId"`
	Tree Sha1Hash `json:"tree"`
	Author string `json:"author"`
	Contact string `json:"contact"`
	CommitMsg string `json:"commitMsg"`
	CommittedAt time.Time `json:"committedAt"`
}

type HashId struct {
	Id string
}

type Sha1Hash struct {
	Hash string
}

func YoGit() {
	fmt.Println("WELCOME TO YOGIT")
}

const (
	LOG_PATH = ".yogit/log/logs"
	LOG_REFS_PATH = ".yogit/log"
	REFS_HEADS = ".yogit/refs/heads"
)

func Init() {
	fmt.Println("Initialising yogit in current dir")
	// use an input package to set the global variables
	err := os.MkdirAll(".yogit", 0777)
	LogErr(err, "Error in making yogit folders")

	subFolders := []string{"objects", "log", "refs"}
	subFiles := []string{"stage", "HEADER", "GLOBALS"}
	logSu 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 1, Expecting-tag: 2, Received: 1
server response: 
 b'Packet-Status \r\n1 \r\n200 \r\n1 \r\n2 \r\n'
packet-sync: 0
Current Chunk to send: 
 bFiles := []string{"logs"}
	// logSubFolders := []string{"refs"}
	refSubFolders := []string{"heads", "tags"}

	for _, folder := range subFolders {
		path := fmt.Sprintf(".yogit/%s", folder)
		err := os.MkdirAll(path, 0777)
		LogErr(err, "Error in making subfolders")
	}

	for _, file := range subFiles {
		path := fmt.Sprintf(".yogit/%s",file)
		_, err := os.OpenFile(path, os.O_CREATE | os.O_RDWR |os.O_TRUNC,  0777)
		LogErr(err, "Error making sub file")
	}

	for _, logFile := range logSubFiles {
		path := fmt.Sprintf(".yogit/log/%s", logFile)
		_, err := os.Create(path)
		LogErr(err, "Error making logFile")
	}

	for _, ref := range refSubFolders {
		path := fmt.Sprintf(".yogit/refs/%s", ref)
		err := os.Mkdir(path, 0777)
		LogErr(err, "Error in making refSubFolders")
	}

	// create refs folder inside log
	errL := os.Mkdir(".yogit/log/refs", 0777)
	LogErr(errL, "Error making refs as sub_folder in .yogit/log/refs, Init()")

	for _, logSubFolder := range refSubFolders {
		path := fmt.Sprintf(".yogit/log/refs/%s", 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 2, Expecting-tag: 3, Received: 2
server response: 
 b'Packet-Status \r\n2 \r\n200 \r\n2 \r\n3 \r\n'
packet-sync: 1
Current Chunk to send: 
  logSubFolder)
		err := os.Mkdir(path, 0777)
		LogErr(err, "Error in making logSubFolder")

	}


	// make master branch by defualt and write it to the HEADER in .yogit
	master, err := os.Create(".yogit/refs/heads/master")
	LogErr(err, "Error in making master branch in heads")
	master.Close()

	header, err := os.OpenFile(".yogit/HEADER", os.O_WRONLY | os.O_TRUNC, 0777)
	LogErr(err, "Error in finding HEADER")
	defer header.Close()

	_, er := fmt.Fprintf(header, "ref:refs/heads/master")
	LogErr(er, "Error in making default write to header")

	fmt.Println(tml.Sprintf("<green>Done initialising</green>\n"))
}

func updateBranch(hash Sha1Hash) {
	// Find what the current HEAD is pointing at
	header, err := os.ReadFile(".yogit/HEADER")
	LogErr(err, "Error in reading HEADER")
	pointingTo := string(header)
	// expect return to be refs/heads/master or any other branch
	_, activeBranch, _:= strings.Cut(pointingTo, ":")

	pathTo := fmt.Sprintf(".yogit/%s", activeBranch)
	branch, err := os.OpenFile(pathTo, os.O_CREATE | os 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 3, Expecting-tag: 4, Received: 3
server response: 
 b'Packet-Status \r\n3 \r\n200 \r\n3 \r\n4 \r\n'
packet-sync: 2
Current Chunk to send: 
 .O_TRUNC | os.O_WRONLY, 0777)
	LogErr(err, "Error in finding the active branch")
	defer branch.Close()

	_, er := branch.Write([]byte(hash.Hash))
	LogErr(er, "Error in updating branch")

}

func updateLog(c Commit) {
	logFile, err := os.OpenFile(LOG_PATH, os.O_CREATE | os.O_RDWR | os.O_APPEND, 0777)
	LogErr(err, "Error opening log file: updateLog()")
	defer logFile.Close()

	fmtC:= fmt.Sprintf( "author:%s  id:%s  message:%s tree:%s at:%s\n", c.Author, c.Id.Hash, c.CommitMsg, c.Tree.Hash, c.CommittedAt.Format("Jan 2, 1990 3:04 PM"))
	logger := log.New(logFile, "", 0)
	logger.Println(fmtC)

	// so when we are updating a log, we want to log it to the current branch the person is also on 
	HEAD, err := os.ReadFile(HEADER_PATH)
	LogErr(err, "Error opening HEAD, See: updateLog()")
	_, currBranch, _ := strings.Cut(string(HEAD), ":")

	logBranchPath := fmt.Sprintf("%s/%s", LOG_REFS_PATH, currBranch)
	logBranch, err := os.OpenFile(logBranchPath, os.O_CREATE | os.O_APPEND | os.O_RDWR, 0777)
	LogErr(err, "Error in openi 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 4, Expecting-tag: 5, Received: 4
server response: 
 b'Packet-Status \r\n4 \r\n200 \r\n4 \r\n5 \r\n'
packet-sync: 3
Current Chunk to send: 
 ng branch path, see updateLog()")
	defer logBranch.Close()

	logBranch.Write([]byte(fmtC))
	fmt.Println(tml.Sprintf("<green> -> New commit stored\n -> Branch Updated</green>\n"))

}

func StagingArea() {
	// we need to write all current files into the staging area in .yogit/stage
	dirEntries, err := os.ReadDir(".")
	LogErr(err, "Error in reading StagingArea(), reading directory")

	stage, err := os.OpenFile(".yogit/stage", os.O_CREATE | os.O_TRUNC | os.O_RDWR, 0777)
	LogErr(err, "Error in opening stage file")
	defer stage.Close()

	for _, path := range dirEntries {
		if path.Name() == ".git" || path.Name() == ".yogit" || path.IsDir() {
			continue
		} 

		info, err := path.Info()
		LogErr(err, "Error in getting file info")

		hashId := SaveToObject(info.Name())
		_, errw := fmt.Fprintf(stage, "%04o %-20s %20s\n", info.Mode().Perm(), hashId, info.Name() )
		LogErr(errw, "Error in writing to file")
	}
	// fmt.Println("check ./yogit/stage")
	fmt.Println(tml.Sprintf("\n  <yellow>---processing index file---</yello 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 5, Expecting-tag: 6, Received: 5
server response: 
 b'Packet-Status \r\n5 \r\n200 \r\n5 \r\n6 \r\n'
packet-sync: 4
Current Chunk to send: 
 w>\n"))
	fmt.Println(tml.Sprintf("  <green>all files ready for saving</green>\n"))
}

// this function is called  in StaginArea(), it serves as hashing and saving to the object store at blob level
// so for every file, we get their hash and compressed content, and write their hash and name to the STAGE file 
// the file writing is done in StagingArea()
// the tree object is created by TreeObject() which basically does the same thing as Add() but its the index file itself
func SaveToObject(file string) Sha1Hash{
	// fmt.Println("adding all files onto the staging area")

	content, err := os.ReadFile(file)
	LogErr(err, "Error occured, could not find file specified")
	// hash the content, get the first 2 names
	hasher := sha1.New() 
	hasher.Write([]byte(content))
	hashedContent := hasher.Sum(nil)
	hashId := hex.EncodeToString(hashedContent)
	objectFolder := hashId[:2]

	byteReader := bytes.NewReader(content)

	// check if saveAt already exists, if it exisit just save the file ther
	saveAt := fmt.Sprintf(".yogit/o 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 6, Expecting-tag: 7, Received: 6
server response: 
 b'Packet-Status \r\n6 \r\n200 \r\n6 \r\n7 \r\n'
packet-sync: 5
Current Chunk to send: 
 bjects/%s", objectFolder)
	errM := os.Mkdir(saveAt, 0777)
	if os.IsExist(errM) {
		fmt.Printf("folder already exists, sharding into -> %s | %s\n", errM, hashId)

		blobPath := fmt.Sprintf("%s/%s", saveAt, hashId[2:])
		blob, err := os.Create(blobPath)
		LogErr(err, "Error in creating blob file in os.IsExist(err)")
		io.Copy(blob, byteReader)

		return Sha1Hash{Hash: hashId}
	}

	
  LogErr(errM, "check Add()")
	
	blobPath := fmt.Sprintf("%s/%s", saveAt, objectFolder[2:])
	blobName := fmt.Sprintf("%s%s", blobPath, hashId[2:])
	blob, err := os.Create(blobName)
	LogErr(err, "Error in making blob")

	// gzipWriter := gzip.NewWriter(blob)
	// gzipWriter.Write(content)
	// gzipWriter.Close()
	io.Copy(blob, byteReader)
	
	// fmt.Printf("%s saved at %s\n", file,  hashId)

	return Sha1Hash{Hash:hashId}
}

func SaveCommit(msg string) {
	const INDEX_PATH = ".yogit/stage"

	content, err := os.ReadFile(INDEX_PATH)
	LogErr(err, "Error occured, could not find file specified")

	treeHash := HasherFn(content)
	hashId := treeHa 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 7, Expecting-tag: 8, Received: 7
server response: 
 b'Packet-Status \r\n7 \r\n200 \r\n7 \r\n8 \r\n'
packet-sync: 6
Current Chunk to send: 
 sh.Hash
	objectFolder := treeHash.Hash[:2]

	saveAt := fmt.Sprintf(".yogit/objects/%s", objectFolder)
	errM := os.Mkdir(saveAt, 0777)

	if os.IsExist(errM) {
		// we want to save the commitObj inside that same folder, 
		// commitPath := fmt.Sprintf("%s/%s")
		fmt.Println("hash ->", hashId)
		fmt.Println("sharding commit", saveAt)
		fmt.Println("treeName ->", hashId[2:])
		treePath := fmt.Sprintf("%s/%s", saveAt , hashId[2:])
		tree, err := os.Create(treePath)
		LogErr(err, "Error occured in SaveCommit(), sharding")
		defer tree.Close()

		byteReader := bytes.NewReader(content)
		io.Copy(tree, byteReader)
	}else {

		LogErr(errM, "check Add()")
	}
	
	treePath := fmt.Sprintf("%s/%s", saveAt, objectFolder[2:])
	treeName := fmt.Sprintf("%s%s", treePath, hashId[2:])
	fmt.Println(treeName)
	tree, err := os.Create(treeName)
	LogErr(err, "Error in making tree")
	defer tree.Close()

	byteReader := bytes.NewReader(content)
	io.Copy(tree, byteReader)
	
	// fmt.Println("hashed_content for tree is store at --- \n",hashId 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 8, Expecting-tag: 9, Received: 8
server response: 
 b'Packet-Status \r\n8 \r\n200 \r\n8 \r\n9 \r\n'
packet-sync: 7
Current Chunk to send: 
 )

	// create a hash for commit data
	commit := Commit{}
	commit.Author = "archive@persona-mp3jpeg"
	// commit.Id = 
	commit.Contact = "<archive@persona-mp3>"
	commit.Tree = treeHash
	commit.CommitMsg = msg
	commit.CommittedAt = time.Now()

	// save commit as it is 
	s := fmt.Sprintf("%v", commit)
	commitHash := HasherFn([]byte(s))
	// we basically just want to get the previous commit 
	HEAD, err := os.ReadFile(HEADER_PATH)	
	LogErr(err, "Error finding HEAD in SaveCommit()")
	_, activeBranch, _ := strings.Cut(string(HEAD), ":")

	pathTo := fmt.Sprintf(".yogit/%s", activeBranch)
	prevCommitHash, err := os.ReadFile(pathTo)
	LogErr(err, "Error finding active branch in SaveCommit()")
	
	parent := Sha1Hash {
		Hash: string(prevCommitHash),
	}

	commit.Parent = parent
	SaveCommitToObj_u(commitHash, commit)

	updateBranch(commitHash)
	commit.Id = commitHash
	updateLog(commit)
}

// this is the checkout functionality in git alias as ntimeline intead git checkout -b playground
func NewTimeLine(timeLine string) {
	pare 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 9, Expecting-tag: 10, Received: 9
server response: 
 b'Packet-Status \r\n9 \r\n200 \r\n9 \r\n10 \r\n'
packet-sync: 8
Current Chunk to send: 
 nt := GetParentCommit_u()
	HEAD, err := os.OpenFile(HEADER_PATH, os.O_RDWR, 0777)
	if err != nil {
		fmt.Println("HEAD FILE NOT FOUND IN", HEADER_PATH)
		panic(err)
	}
	defer HEAD.Close()
	
	refs := fmt.Sprintf("ref:refs/heads/%s", timeLine)
	HEAD.Truncate(0)
	HEAD.Write([]byte(refs))
	newTimeLine := fmt.Sprintf("%s/%s", BRANCH_PATH, timeLine)

	
	newBranch, err := os.OpenFile(newTimeLine, os.O_CREATE | os.O_RDWR, 0777)
	LogErr(err, "Error creating new timeline in NewTimeLine()")
	defer newBranch.Close()

	newBranch.Write([]byte(parent.Hash))
	fmt.Printf("new timeline made, have fun in %s", timeLine)

}


type State struct {
	Perm string
	Sha1Id string
	File string
}
// we coud basically check for all the files in the current directory firstly
// and then if they exist, we go look for their hash and content 
// overwrite the current state with the content from the object by trunc && copying
// and for files that dont exist, we can just remake them according to Perm

func TravelTo(hash string) {
	// go to obje 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 10, Expecting-tag: 11, Received: 10
server response: 
 b'Packet-Status \r\n10 \r\n200 \r\n10 \r\n11 \r\n'
packet-sync: 9
Current Chunk to send: 
 ct path to look for the first two letters of the hash passed in 
	folderName := hash[:2]
	fileName := hash[2:]
	fmt.Println(tml.Sprintf(" <yellow>  ---locating folders for commit--- </yellow>"))

	commitLocation := fmt.Sprintf("%s/%s/%s", OBJECT_PATH, folderName, fileName)
	content, err := os.ReadFile(commitLocation)
	LogErr(err, "Error in getting commit in multiverse, TravelTo()")

	// fmt.Println("here is the file state from the past")
	fmt.Println(tml.Sprintf(" <green> -> Commit found\n -> Changing directory state</green>"))
	_, treeInfo, _ := strings.Cut(string(content), "tree:")
	// fmt.Printf("\nthis is the tree Id -> %s\n", treeInfo[:40])

	treeHash := treeInfo[:40]
	// fmt.Println("locating stage area as at then...")
	
	treeFolder := treeHash[:2] 
	treeName := treeHash[2:]
	treePath := fmt.Sprintf("%s/%s/%s", OBJECT_PATH, treeFolder, treeName) 

	dirSnapshot, err := os.OpenFile(treePath, os.O_RDONLY, 0)
	LogErr(err, "Error in getting directorySnapshot, TravelTo()")
	defer dirSnapshot.Close()

	// fmt. 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 11, Expecting-tag: 12, Received: 11
server response: 
 b'Packet-Status \r\n11 \r\n200 \r\n11 \r\n12 \r\n'
packet-sync: 10
Current Chunk to send: 
 Printf("\nDirectory snapshot to be read into struct -> \n%s\n", string(dirSnapshot))

	scanner := bufio.NewScanner(dirSnapshot)

	for scanner.Scan() {
		state := State{}
		line := scanner.Text()
		fmt.Println(line)
		// the file returns content stoed as 0664  {40digithash} %20sfileName
		perm, content, _ := strings.Cut(line, "{")
		fileHash, fileName, _ := strings.Cut(content, "}")

		state.Perm = perm
		state.File = strings.TrimSpace(fileName)
		state.Sha1Id = fileHash
		
		// fmt.Printf("add to struct for this line %s | %s | %s->\n", perm,  fileHash, strings.TrimSpace(fileName))

		BuildState(state)
	}
}


func BuildState(state State) {
	// just regular file path build up 
	folderLocation := state.Sha1Id[:2]
	fileHash := state.Sha1Id[2:]

	pathToF := fmt.Sprintf("%s/%s/%s", OBJECT_PATH, folderLocation, fileHash)
	
	snapshot, err := os.Open(pathToF)
	LogErr(err, "Error in opening snapshot file, BuildState")
	defer snapshot.Close()


	// tame to open file in current directory
	dst, err := os.OpenFile(state.Fi 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 12, Expecting-tag: 13, Received: 12
server response: 
 b'Packet-Status \r\n12 \r\n200 \r\n12 \r\n13 \r\n'
packet-sync: 11
Current Chunk to send: 
 le, os.O_CREATE | os.O_TRUNC | os.O_RDWR, 0777)
	LogErr(err, "Error in opening file in current directory, BuildState()")
	defer dst.Close()

	io.Copy(dst, snapshot)

	// fmt.Printf("done copying prev state -> %s-> to %s\n ", state.Sha1Id, state.File)
	fmt.Println(tml.Sprintf(" <green> -> Working directory has been updated</green>"))
}


// switchTo old branch
// check if file exists in refs/heads and then read the commit hash
// locate the hash in object store and build from there 
// goes to previous existing branch, similar with git checkout master
func SwitchTo(branch string) {
	currBranch, err:= os.ReadFile(HEADER_PATH)
	LogErr(err, "Error in reading HEADER, SwitchTo()")

	_,currBName, _ := strings.Cut(string(currBranch), "heads/")

	if currBName == branch {
		fmt.Printf("Already on current branch specified -> %s %s\n", string(currBranch), currBName)
		return
	}

	path := fmt.Sprintf("%s/%s", REFS_HEADS, branch)
	latestCommit, err := os.ReadFile(path)
	if os.IsNotExist(err) {
		// fmt.Printf("Could not fi 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 13, Expecting-tag: 14, Received: 13
server response: 
 b'Packet-Status \r\n13 \r\n200 \r\n13 \r\n14 \r\n'
packet-sync: 12
Current Chunk to send: 
 nd branch specified with -> %s, try creating one first\n", branch)
		fmt.Println(tml.Sprintf(" <red> -> Could not find branch specified with -> %s, try creating one first\n</red>", branch))
		return
	}else if err != nil {
		LogErr(err, "An error occured, SwitchTo()")
	}

	// fmt.Println(tml.Sprintf(" <yellow> ---Latest commit from %s </yellow>"))

	// fmt.Printf("latest commit read from %s is %s", branch, string(latestCommit))
	TravelTo(string(latestCommit))
}

func CheckLogs() {

	tbl := table.New(os.Stdout)
	tbl.SetHeaders("hashId", "commitMessage", "commitedAt")
	tbl.SetPadding(2)

	logs, err := os.Open(".yogit/log/logs")
	LogErr(err, "Error occured in opening log file, CheckLogs()")
	defer logs.Close()

	scanner := bufio.NewScanner(logs)
	for scanner.Scan() {
		line := scanner.Text()
		// fmt.Println(line)
		_, hashId, _ := strings.Cut(line, "id:")
		id, msgSlice, _ := strings.Cut(hashId, "message:")
		_, time, _ := strings.Cut(hashId, "at:")
		msg, _, _ := strings.Cut(msgSlice, "tree")

		tbl.AddRow(stri 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 14, Expecting-tag: 15, Received: 14
server response: 
 b'Packet-Status \r\n14 \r\n200 \r\n14 \r\n15 \r\n'
packet-sync: 13
Current Chunk to send: 
 ngs.TrimSpace(id), strings.TrimSpace(msg), strings.TrimSpace(time))
	}
	
	tbl.Render()
}
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 14
 === All packets sent, closing connection ===
Streaming:  yogit/utilis.go
EOF file reached, nothing more to read
Total packets to send to server: 2

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 package yogit

import (
	"fmt"
	"log"
	"os"
	"crypto/sha1"
	"strings"
	"encoding/hex"
	"github.com/liamg/tml"
)

const (
	OBJECT_PATH = ".yogit/objects"
	BRANCH_PATH = ".yogit/refs/heads"
	HEADER_PATH = ".yogit/HEADER"
)

func LogErr(err error, msg string) {
	if err != nil {
		yoErr := tml.Sprintf("Error: <red>%s</red>", msg)
		fmt.Println(yoErr)
		log.Fatal(err)
	}
}

func HasherFn(content []byte) Sha1Hash {
	hasher := sha1.New()
	hasher.Write(content)
	hashedContent := hasher.Sum(nil)

	sha1Hash := hex.EncodeToString(hashedContent)

	return Sha1Hash{Hash: sha1Hash}
}

func SaveCommitToObj_u(commitHash Sha1Hash, commit Commit) {
	folderName := commitHash.Hash[:2]
	fileName := commitHash.Hash[2:]

	savePath := fmt.Sprintf("%s/%s", OBJECT_PATH, folderName)
	filePath := fmt.Sprintf("%s/%s", savePath, fileName)

	err := os.Mkdir(savePath, 0777)
	LogErr(err, "Error in making path for commit")

	// creating commit file 
	commitFile, err := os.OpenFile(filePath, os.O_CREATE | os.O_RDWR, 0777)
	LogErr(err, "Error ma 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 1, Expecting-tag: 2, Received: 1
server response: 
 b'Packet-Status \r\n1 \r\n200 \r\n1 \r\n2 \r\n'
packet-sync: 0
Current Chunk to send: 
 king commit file")
	defer commitFile.Close()
	commit.Id = commitHash
	// commit.Parent = Parent

	_, errW := fmt.Fprintf(commitFile, "parent:%s author:%s  commitHash:%s  commitMessage:%s tree:%s committedAt:%s\n", 
													commit.Parent.Hash, commit.Author, commit.Id.Hash, commit.CommitMsg,
													commit.Tree.Hash, commit.CommittedAt.Format("Jan 2, 1990 3:04 PM"))

	LogErr(errW, "Error writing to commit file")

}


func GetParentCommit_u() Sha1Hash{
	// we basically just want to get the previous commit 
	HEAD, err := os.ReadFile(HEADER_PATH)	
	LogErr(err, "Error finding HEAD in SaveCommit()")
	_, activeBranch, _ := strings.Cut(string(HEAD), ":")

	pathTo := fmt.Sprintf(".yogit/%s", activeBranch)
	prevCommitHash, err := os.ReadFile(pathTo)
	LogErr(err, "Error finding active branch in SaveCommit()")

	return Sha1Hash{Hash: string(prevCommitHash)}
}
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 1
 === All packets sent, closing connection ===
Streaming:  docs/image-4.png
EOF file reached, nothing more to read
Total packets to send to server: 27

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Sending whole directory to the server...
Files ready...
Streaming:  README.md
EOF file reached, nothing more to read
Total packets to send to server: 4

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 # yogit

The main intention of yogit was for two things:
1. Learn Golang 
2. While learning Go, to build something.
3. Git. Why Git? I use it almost everyday, might as well try and actually understand its inner workings.

This is was pratically doubling two things at the same time: Learing Golang and rebuiling Git. The previous project can be found at [ git_project](https://github.com/persona-mp3/git_project.git). There I explain major innerworkings of how Git works like is Data structure using a Directed Acyclic Graph, zlib compression, concepts of pointers and branches, basically like a time machine. I also made used of visual diagrams to actually make the learning nice

But this is a practical version for the whole project, although the scope has changed to help people understand Git better and the commandline better, this is where I will stop for now.

# Installation
``` bash 
git clone https://github.com/persona-mp3/yogit.git
cd yogit
```

This will clone thewhole repository into your current working fol 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 1, Expecting-tag: 2, Received: 1
server response: 
 b'Packet-Status \r\n1 \r\n200 \r\n1 \r\n2 \r\n'
packet-sync: 0
Current Chunk to send: 
 der and you change youir current directory to yogit

You will see this script called *setup.sh*. If using any vim emulator you can use it to edit or take a look at the code

``` bash
userName@users ~/yogit $ bash setup.sh
```

That will set up yogit to be globally available on your system. To check it run this 

``` bash 
yogit
 ->  WELCOME TO YOGIT
``` 

To see how it works you can go into any test folder of your choice and run basic git commands and it works exactly the same. The logs are left intentionally to make the user aware of whats going on instead of looking at Git like a complex tool, although it is, its simple too, with the right understanding.

### side note -> You can configure the commandline arguments to suit your interests and it won't affect anything inside the main.go file

```bash
yogit init

// this creates a .yogit folder in the current working directory just like .git
``` 

![Alt text](./docs/image-2.png)

### See main.go for basic commands,

            yogit add . -> git add .
        





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 2, Expecting-tag: 3, Received: 2
server response: 
 b'Packet-Status \r\n2 \r\n200 \r\n2 \r\n3 \r\n'
packet-sync: 1
Current Chunk to send: 
      yogit save "" -> git commit -m ""
            yogit ntimeline "" -> git checkout -b "branch_name"
            yogit traveto "" -> git checkout "commit_id"
            yogit switchto "" -> git checkout [branch_name]



# yogit instructions


```bash
yogit add .
```

This basically adds all files in the current directory to staging area just like how git does


```bash
yogit save "message goes in here" 
``` 

To save a commit, just like ```git commit -m "inital commit"``` 
![Alt text](./docs/image-5.png)




### Other features 
1. Checkout
2. Switching branches
3. Logging
<br>

# FUTURE IMPROVEMENTS

As stated with scope above, as most people are new to the command line like I am, I also plan on adding a nice terminal user interface, as seen below

![Alt text](./docs/image-6.png)

Other major integrations that I would like to include is actually helping with the merge conflicts as most people said its hard to understand.



# CONTRIBUTING

### Clone the repo
Make sure you have the go compiler installed at  





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 3, Expecting-tag: 4, Received: 3
server response: 
 b'Packet-Status \r\n3 \r\n200 \r\n3 \r\n4 \r\n'
packet-sync: 2
Current Chunk to send: 
 their offical [website](https://go.dev/doc/install)
```bash
git clone https://github.com/persona-mp3/yogit.git
cd yogit
```

### Run the project
```bash
go run main.go 

# you can refer to the instructions as regular command line args or set it up globally
# go run main.go init 
# go run main.go init 
```

### New updates
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 3
 === All packets sent, closing connection ===
Streaming:  main.go
EOF file reached, nothing more to read
Total packets to send to server: 2

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 package main 

import (
	"fmt"	
	"os"
	"yogit/yogit"
)

func ReadCommandLine(args []string) {
	cmds := len(args)

	if cmds <= 1 {
		yogit.YoGit()
		// fmt.Println("Print instruction manual or enter interactive mode?")
		return
	}

	switch {

	case cmds == 2: {
		if args[1] == "init" {
			yogit.Init()
			return
		}

		// if args[1] == "logs" {
		// 	yogit.Init()
		// 	return
		// }
		
		if args[1] == "clogs" {
			yogit.CheckLogs()
			return
		}
		return
	}

	case cmds == 3: {
		// fmt.Println("command line args has two arguments passed in")
		if args[1] == "save" && args[2] != "" {
			yogit.SaveCommit(args[2])
			return
		}

		if args[1] == "add" && args[2] != "" {
			// yogit.Add(args[2])
			yogit.StagingArea()
			return
		}

		if args[1] == "ntimeline" && args[2] != "" {
			yogit.NewTimeLine(args[2])
		}

		if args[1] == "travelto" && args[2] != "" {
			yogit.TravelTo(args[2])
		}

		if args[1] == "switchto" && args[2] != "" {
			yogit.SwitchTo(args[2])
		}
		
		return
	}

	default  :
		fmt.Println("idk what 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 1, Expecting-tag: 2, Received: 1
server response: 
 b'Packet-Status \r\n1 \r\n200 \r\n1 \r\n2 \r\n'
packet-sync: 0
Current Chunk to send: 
  this guy entered -> ", cmds)
		return
	}

}

func main() {
	
	ReadCommandLine(os.Args)
}
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 1
 === All packets sent, closing connection ===
Streaming:  cwdLog.txt
EOF file reached, nothing more to read
Total packets to send to server: 33

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 Sending whole directory to the server...
Files ready...
Streaming:  README.md
EOF file reached, nothing more to read
Total packets to send to server: 4

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 # yogit

The main intention of yogit was for two things:
1. Learn Golang 
2. While learning Go, to build something.
3. Git. Why Git? I use it almost everyday, might as well try and actually understand its inner workings.

This is was pratically doubling two things at the same time: Learing Golang and rebuiling Git. The previous project can be found at [ git_project](https://github.com/persona-mp3/git_project.git). There I explain major innerworkings of how Git works like is Data structure using a Directed Acyclic Graph, zlib compression, concepts of pointers and branches, basically like a time machine. I also made used of visual diagrams to actually make the 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 1, Expecting-tag: 2, Received: 1
server response: 
 b'Packet-Status \r\n1 \r\n200 \r\n1 \r\n2 \r\n'
packet-sync: 0
Current Chunk to send: 
  learning nice

But this is a practical version for the whole project, although the scope has changed to help people understand Git better and the commandline better, this is where I will stop for now.

# Installation
``` bash 
git clone https://github.com/persona-mp3/yogit.git
cd yogit
```

This will clone thewhole repository into your current working fol 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 1, Expecting-tag: 2, Received: 1
server response: 
 b'Packet-Status \r\n1 \r\n200 \r\n1 \r\n2 \r\n'
packet-sync: 0
Current Chunk to send: 
 der and you change youir current directory to yogit

You will see this script called *setup.sh*. If using any vim emulator you can use it to edit or take a look at the code

``` bash
userName@users ~/yogit $ bash setup.sh
```

That will set up yogit to be globally available on your system. To check it run this 

``` bash 
yogit
 ->  WELCOME TO YOGIT
``` 

To see how it works you can go into any 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 2, Expecting-tag: 3, Received: 2
server response: 
 b'Packet-Status \r\n2 \r\n200 \r\n2 \r\n3 \r\n'
packet-sync: 1
Current Chunk to send: 
  test folder of your choice and run basic git commands and it works exactly the same. The logs are left intentionally to make the user aware of whats going on instead of looking at Git like a complex tool, although it is, its simple too, with the right understanding.

### side note -> You can configure the commandline arguments to suit your interests and it won't affect anything inside the main.go file

```bash
yogit init

// this creates a .yogit folder in the current working directory just like .git
``` 

![Alt text](./docs/image-2.png)

### See main.go for basic commands,

            yogit add . -> git add .
        





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 2, Expecting-tag: 3, Received: 2
server response: 
 b'Packet-Status \r\n2 \r\n200 \r\n2 \r\n3 \r\n'
packet-sync: 1
Current Chunk to send: 
      yogit save "" -> git commit -m ""
            yogit ntimeline "" -> git checkout -b "branch_name"
            yogit traveto 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 3, Expecting-tag: 4, Received: 3
server response: 
 b'Packet-Status \r\n3 \r\n200 \r\n3 \r\n4 \r\n'
packet-sync: 2
Current Chunk to send: 
  "" -> git checkout "commit_id"
            yogit switchto "" -> git checkout [branch_name]



# yogit instructions


```bash
yogit add .
```

This basically adds all files in the current directory to staging area just like how git does


```bash
yogit save "message goes in here" 
``` 

To save a commit, just like ```git commit -m "inital commit"``` 
![Alt text](./docs/image-5.png)




### Other features 
1. Checkout
2. Switching branches
3. Logging
<br>

# FUTURE IMPROVEMENTS

As stated with scope above, as most people are new to the command line like I am, I also plan on adding a nice terminal user interface, as seen below

![Alt text](./docs/image-6.png)

Other major integrations that I would like to include is actually helping with the merge conflicts as most people said its hard to understand.



# CONTRIBUTING

### Clone the repo
Make sure you have the go compiler installed at  





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 4, Expecting-tag: 5, Received: 4
server response: 
 b'Packet-Status \r\n4 \r\n200 \r\n4 \r\n5 \r\n'
packet-sync: 3
Current Chunk to send: 
  3, Expecting-tag: 4, Received: 3
server response: 
 b'Packet-Status \r\n3 \r\n200 \r\n3 \r\n4 \r\n'
packet-sync: 2
Current Chunk to send: 
 their offical [website](https://go.dev/doc/install)
```bash
git clone https://github.com/persona-mp3/yogit.git
cd yogit
```

### Run the project
```bash
go run main.go 

# you can refer to the instructions as regular command line args or set it up globally
# go run main.go init 
# go run main.go init 
```

### New updates
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 3
 === All packets sent, closing connection ===
Streaming:  main.go
EOF file reached, nothing more to read
Total packets to send to server: 2

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 package main 

import (
	"fmt"	
	"os"
 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 5, Expecting-tag: 6, Received: 5
server response: 
 b'Packet-Status \r\n5 \r\n200 \r\n5 \r\n6 \r\n'
packet-sync: 4
Current Chunk to send: 
 	"yogit/yogit"
)

func ReadCommandLine(args []string) {
	cmds := len(args)

	if cmds <= 1 {
		yogit.YoGit()
		// fmt.Println("Print instruction manual or enter interactive mode?")
		return
	}

	switch {

	case cmds == 2: {
		if args[1] == "init" {
			yogit.Init()
			return
		}

		// if args[1] == "logs" {
		// 	yogit.Init()
		// 	return
		// }
		
		if args[1] == "clogs" {
			yogit.CheckLogs()
			return
		}
		return
	}

	case cmds == 3: {
		// fmt.Println("command line args has two arguments passed in")
		if args[1] == "save" && args[2] != "" {
			yogit.SaveCommit(args[2])
			return
		}

		if args[1] == "add" && args[2] != "" {
			// yogit.Add(args[2])
			yogit.StagingArea()
			return
		}

		if args[1] == "ntimeline" && args[2] != "" {
			yogit.NewTimeLine(args[2])
		}

		if args[1] == "travelto" && args[2] != "" {
			yogit.TravelTo(args[2])
		}

		if args[1] == "switchto" && args[2] != "" {
			yogit.SwitchTo(args[2])
		}
		
		return
	}

	default  :
		fmt.Println("idk what 





 == waiting on packet status fr 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 6, Expecting-tag: 7, Received: 6
server response: 
 b'Packet-Status \r\n6 \r\n200 \r\n6 \r\n7 \r\n'
packet-sync: 5
Current Chunk to send: 
 om encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 1, Expecting-tag: 2, Received: 1
server response: 
 b'Packet-Status \r\n1 \r\n200 \r\n1 \r\n2 \r\n'
packet-sync: 0
Current Chunk to send: 
  this guy entered -> ", cmds)
		return
	}

}

func main() {
	
	ReadCommandLine(os.Args)
}
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 1
 === All packets sent, closing connection ===
Streaming:  cwdLog.txt
EOF file reached, nothing more to read
Total packets to send to server: 0

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

 === All packets sent, closing connection ===
Streaming:  install.sh
EOF file reached, nothing more to read
Total packets to send to server: 1

 === Waiting to get Acked === 


 === packet sent, awaiting  





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 7, Expecting-tag: 8, Received: 7
server response: 
 b'Packet-Status \r\n7 \r\n200 \r\n7 \r\n8 \r\n'
packet-sync: 6
Current Chunk to send: 
 acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 #!/usr/bin/bash

echo "Installing and configuring Yogit" 
echo "Building executable..."
$(go build main.go)

windows="main.exe"
linux="main"

if [ -f "$linux" ]; then
  echo "Building for linux systems..."
  BuildLinux
else 
  echo "Building for windows system"
  curr_dir=pwd
  exec_path=$curr_dir/$linux
  echo "fatal: Build failed, please refer to docs at https://github.com/persona-mp3/yogit.git"
  echo "You can directly install the build from the repo"
fi


BuildLinux(){
  echo "Building execution Path"
  curr_dir=pwd
  exec_path=$curr_dir/$linux

  echo "Writing to bashrc..."
  config="alias yogit=$exec_path"
  echo $config

  echo $config >> ~/.bashrc
  echo "--- Confirm config was successful"
  echo "Run `yogit` to confirm or check .bashrc for $config"
}

 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed  





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 8, Expecting-tag: 9, Received: 8
server response: 
 b'Packet-Status \r\n8 \r\n200 \r\n8 \r\n9 \r\n'
packet-sync: 7
Current Chunk to send: 
 sending packets? from server
server response: 
 b''
packet-sync: 0
 === All packets sent, closing connection ===
Streaming:  .gitignore
EOF file reached, nothing more to read
Total packets to send to server: 1

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 todo
server.ts 
.yogit
change
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 0
 === All packets sent, closing connection ===
Streaming:  go.sum
EOF file reached, nothing more to read
Total packets to send to server: 2

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 github.com/aquasecurity/table v1.10.0 h1:gPWV28qp9XSlvXdT3 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 9, Expecting-tag: 10, Received: 9
server response: 
 b'Packet-Status \r\n9 \r\n200 \r\n9 \r\n10 \r\n'
packet-sync: 8
Current Chunk to send: 
 ku8yKQoZE6II0vsmegKpW+dB08=
github.com/aquasecurity/table v1.10.0/go.mod h1:eqOmvjjB7AhXFgFqpJUEE/ietg7RrMSJZXyTN8E/wZw=
github.com/liamg/tml v0.7.0 h1:0cVok661KuQy659aFpXpem8mXUDroREuWc1p/+y7hfU=
github.com/liamg/tml v0.7.0/go.mod h1:Vuzs4Dn44Awoyd0MLl2EuJR++l1NlFqU6BJk0oxVYX4=
github.com/mattn/go-runewidth v0.0.13 h1:lTGmDsbAYt5DmK6OnoV7EuIF1wEIFAcxld6ypU4OSgU=
github.com/mattn/go-runewidth v0.0.13/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/rivo/uniseg v0.2.0 h1:S1pD9weZBuJdFmowNwbpi7BJ8TNftyUImj/0WQi72jY=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1 h1:SrN+KX8Art/Sf4HNj6Zcz06G7VEz+7w9tdXTPOZ7+l4=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/term v0.0.0-20220526004731-065cf7ba2467 h1:CBpWXWQpIRjzmkkA+M7q9Fqnwd2mZr3AFqexg8YTfoM=
golang.org/x/term v0.0.0-20220526004 





 == waiting on packet status from encoder.verify_pa 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 10, Expecting-tag: 11, Received: 10
server response: 
 b'Packet-Status \r\n10 \r\n200 \r\n10 \r\n11 \r\n'
packet-sync: 9
Current Chunk to send: 
 cket_status() == 


 === verifying last packet sent === 

Current-tag: 1, Expecting-tag: 2, Received: 1
server response: 
 b'Packet-Status \r\n1 \r\n200 \r\n1 \r\n2 \r\n'
packet-sync: 0
Current Chunk to send: 
 731-065cf7ba2467/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 1
 === All packets sent, closing connection ===
Streaming:  go.mod
EOF file reached, nothing more to read
Total packets to send to server: 1

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 module yogit

go 1.24.3

require (
	github.com/aquasecurity/table v1.10.0 // indirect
	github.com/liamg/tml v0.7.0 // indirect
	github.com/mattn/go-runewidth v0.0.13 // indirect
	github.com/rivo/uniseg v0.2.0 // indirect
 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 11, Expecting-tag: 12, Received: 11
server response: 
 b'Packet-Status \r\n11 \r\n200 \r\n11 \r\n12 \r\n'
packet-sync: 10
Current Chunk to send: 
 	golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1 // indirect
	golang.org/x/term v0.0.0-20220526004731-065cf7ba2467 // indirect
)
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 0
 === All packets sent, closing connection ===
Streaming:  yogit/yogit.go
EOF file reached, nothing more to read
Total packets to send to server: 15

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 package yogit

import (
	// "compress/gzip"
	"bufio"
	"bytes"
	"crypto/sha1"
	"encoding/hex"
	"fmt"
	"io"
	"log"
	"os"
	"strings"
	"time"

	"github.com/aquasecurity/table"
	"github.com/liamg/tml"
	// "github.com/liamg/tml"
)

type Commit struct {
	Parent Sha1Hash `json:"parent"`
	Id Sha1Hash `json:"hashId"`
	Tree Sha1Hash `json:"tree"`
	Author string `json:"au 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 12, Expecting-tag: 13, Received: 12
server response: 
 b'Packet-Status \r\n12 \r\n200 \r\n12 \r\n13 \r\n'
packet-sync: 11
Current Chunk to send: 
 thor"`
	Contact string `json:"contact"`
	CommitMsg string `json:"commitMsg"`
	CommittedAt time.Time `json:"committedAt"`
}

type HashId struct {
	Id string
}

type Sha1Hash struct {
	Hash string
}

func YoGit() {
	fmt.Println("WELCOME TO YOGIT")
}

const (
	LOG_PATH = ".yogit/log/logs"
	LOG_REFS_PATH = ".yogit/log"
	REFS_HEADS = ".yogit/refs/heads"
)

func Init() {
	fmt.Println("Initialising yogit in current dir")
	// use an input package to set the global variables
	err := os.MkdirAll(".yogit", 0777)
	LogErr(err, "Error in making yogit folders")

	subFolders := []string{"objects", "log", "refs"}
	subFiles := []string{"stage", "HEADER", "GLOBALS"}
	logSu 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 1, Expecting-tag: 2, Received: 1
server response: 
 b'Packet-Status \r\n1 \r\n200 \r\n1 \r\n2 \r\n'
packet-sync: 0
Current Chunk to send: 
 bFiles := []string{"logs"}
	// logSubFolders := []string{"refs"}
	refSubFolders := []string{" 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 13, Expecting-tag: 14, Received: 13
server response: 
 b'Packet-Status \r\n13 \r\n200 \r\n13 \r\n14 \r\n'
packet-sync: 12
Current Chunk to send: 
 heads", "tags"}

	for _, folder := range subFolders {
		path := fmt.Sprintf(".yogit/%s", folder)
		err := os.MkdirAll(path, 0777)
		LogErr(err, "Error in making subfolders")
	}

	for _, file := range subFiles {
		path := fmt.Sprintf(".yogit/%s",file)
		_, err := os.OpenFile(path, os.O_CREATE | os.O_RDWR |os.O_TRUNC,  0777)
		LogErr(err, "Error making sub file")
	}

	for _, logFile := range logSubFiles {
		path := fmt.Sprintf(".yogit/log/%s", logFile)
		_, err := os.Create(path)
		LogErr(err, "Error making logFile")
	}

	for _, ref := range refSubFolders {
		path := fmt.Sprintf(".yogit/refs/%s", ref)
		err := os.Mkdir(path, 0777)
		LogErr(err, "Error in making refSubFolders")
	}

	// create refs folder inside log
	errL := os.Mkdir(".yogit/log/refs", 0777)
	LogErr(errL, "Error making refs as sub_folder in .yogit/log/refs, Init()")

	for _, logSubFolder := range refSubFolders {
		path := fmt.Sprintf(".yogit/log/refs/%s", 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying  





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 14, Expecting-tag: 15, Received: 14
server response: 
 b'Packet-Status \r\n14 \r\n200 \r\n14 \r\n15 \r\n'
packet-sync: 13
Current Chunk to send: 
 last packet sent === 

Current-tag: 2, Expecting-tag: 3, Received: 2
server response: 
 b'Packet-Status \r\n2 \r\n200 \r\n2 \r\n3 \r\n'
packet-sync: 1
Current Chunk to send: 
  logSubFolder)
		err := os.Mkdir(path, 0777)
		LogErr(err, "Error in making logSubFolder")

	}


	// make master branch by defualt and write it to the HEADER in .yogit
	master, err := os.Create(".yogit/refs/heads/master")
	LogErr(err, "Error in making master branch in heads")
	master.Close()

	header, err := os.OpenFile(".yogit/HEADER", os.O_WRONLY | os.O_TRUNC, 0777)
	LogErr(err, "Error in finding HEADER")
	defer header.Close()

	_, er := fmt.Fprintf(header, "ref:refs/heads/master")
	LogErr(er, "Error in making default write to header")

	fmt.Println(tml.Sprintf("<green>Done initialising</green>\n"))
}

func updateBranch(hash Sha1Hash) {
	// Find what the current HEAD is pointing at
	header, err := os.ReadFile(".yogit/HEADER")
	LogErr(err, "Error in reading HEADER")
	pointingTo := string(header)
	// expect return to be refs/heads/maste 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 15, Expecting-tag: 16, Received: 15
server response: 
 b'Packet-Status \r\n15 \r\n200 \r\n15 \r\n16 \r\n'
packet-sync: 14
Current Chunk to send: 
 r or any other branch
	_, activeBranch, _:= strings.Cut(pointingTo, ":")

	pathTo := fmt.Sprintf(".yogit/%s", activeBranch)
	branch, err := os.OpenFile(pathTo, os.O_CREATE | os 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 3, Expecting-tag: 4, Received: 3
server response: 
 b'Packet-Status \r\n3 \r\n200 \r\n3 \r\n4 \r\n'
packet-sync: 2
Current Chunk to send: 
 .O_TRUNC | os.O_WRONLY, 0777)
	LogErr(err, "Error in finding the active branch")
	defer branch.Close()

	_, er := branch.Write([]byte(hash.Hash))
	LogErr(er, "Error in updating branch")

}

func updateLog(c Commit) {
	logFile, err := os.OpenFile(LOG_PATH, os.O_CREATE | os.O_RDWR | os.O_APPEND, 0777)
	LogErr(err, "Error opening log file: updateLog()")
	defer logFile.Close()

	fmtC:= fmt.Sprintf( "author:%s  id:%s  message:%s tree:%s at:%s\n", c.Author, c.Id.Hash, c.CommitMsg, c.Tree.Hash, c.CommittedAt.Format("Jan 2, 1990 3:04 PM"))
	logger := log.New(logFile, "", 0)
	logge 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 16, Expecting-tag: 17, Received: 16
server response: 
 b'Packet-Status \r\n16 \r\n200 \r\n16 \r\n17 \r\n'
packet-sync: 15
Current Chunk to send: 
 r.Println(fmtC)

	// so when we are updating a log, we want to log it to the current branch the person is also on 
	HEAD, err := os.ReadFile(HEADER_PATH)
	LogErr(err, "Error opening HEAD, See: updateLog()")
	_, currBranch, _ := strings.Cut(string(HEAD), ":")

	logBranchPath := fmt.Sprintf("%s/%s", LOG_REFS_PATH, currBranch)
	logBranch, err := os.OpenFile(logBranchPath, os.O_CREATE | os.O_APPEND | os.O_RDWR, 0777)
	LogErr(err, "Error in openi 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 4, Expecting-tag: 5, Received: 4
server response: 
 b'Packet-Status \r\n4 \r\n200 \r\n4 \r\n5 \r\n'
packet-sync: 3
Current Chunk to send: 
 ng branch path, see updateLog()")
	defer logBranch.Close()

	logBranch.Write([]byte(fmtC))
	fmt.Println(tml.Sprintf("<green> -> New commit stored\n -> Branch Updated</green>\n"))

}

func StagingArea() {
	// we need to write all current files into the staging area in .yogit/stage
	dirEntries, err := os.ReadDi 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 17, Expecting-tag: 18, Received: 17
server response: 
 b'Packet-Status \r\n17 \r\n200 \r\n17 \r\n18 \r\n'
packet-sync: 16
Current Chunk to send: 
 r(".")
	LogErr(err, "Error in reading StagingArea(), reading directory")

	stage, err := os.OpenFile(".yogit/stage", os.O_CREATE | os.O_TRUNC | os.O_RDWR, 0777)
	LogErr(err, "Error in opening stage file")
	defer stage.Close()

	for _, path := range dirEntries {
		if path.Name() == ".git" || path.Name() == ".yogit" || path.IsDir() {
			continue
		} 

		info, err := path.Info()
		LogErr(err, "Error in getting file info")

		hashId := SaveToObject(info.Name())
		_, errw := fmt.Fprintf(stage, "%04o %-20s %20s\n", info.Mode().Perm(), hashId, info.Name() )
		LogErr(errw, "Error in writing to file")
	}
	// fmt.Println("check ./yogit/stage")
	fmt.Println(tml.Sprintf("\n  <yellow>---processing index file---</yello 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 5, Expecting-tag: 6, Received: 5
server response: 
 b'Packet-Status \r\n5 \r\n200 \r\n5 \r\n6 \r\n'
packet-sync: 4
Current Chunk to send: 
 w>\n"))
	fmt.Println(tml.Sprintf("  <gree 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 18, Expecting-tag: 19, Received: 18
server response: 
 b'Packet-Status \r\n18 \r\n200 \r\n18 \r\n19 \r\n'
packet-sync: 17
Current Chunk to send: 
 n>all files ready for saving</green>\n"))
}

// this function is called  in StaginArea(), it serves as hashing and saving to the object store at blob level
// so for every file, we get their hash and compressed content, and write their hash and name to the STAGE file 
// the file writing is done in StagingArea()
// the tree object is created by TreeObject() which basically does the same thing as Add() but its the index file itself
func SaveToObject(file string) Sha1Hash{
	// fmt.Println("adding all files onto the staging area")

	content, err := os.ReadFile(file)
	LogErr(err, "Error occured, could not find file specified")
	// hash the content, get the first 2 names
	hasher := sha1.New() 
	hasher.Write([]byte(content))
	hashedContent := hasher.Sum(nil)
	hashId := hex.EncodeToString(hashedContent)
	objectFolder := hashId[:2]

	byteReader := bytes.NewReader(content)

	// check if saveAt already exists, if it exisit just save the file ther
	saveAt := fmt.Sprintf(".yogit/o 





 == waiting on packet status from  





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 19, Expecting-tag: 20, Received: 19
server response: 
 b'Packet-Status \r\n19 \r\n200 \r\n19 \r\n20 \r\n'
packet-sync: 18
Current Chunk to send: 
 encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 6, Expecting-tag: 7, Received: 6
server response: 
 b'Packet-Status \r\n6 \r\n200 \r\n6 \r\n7 \r\n'
packet-sync: 5
Current Chunk to send: 
 bjects/%s", objectFolder)
	errM := os.Mkdir(saveAt, 0777)
	if os.IsExist(errM) {
		fmt.Printf("folder already exists, sharding into -> %s | %s\n", errM, hashId)

		blobPath := fmt.Sprintf("%s/%s", saveAt, hashId[2:])
		blob, err := os.Create(blobPath)
		LogErr(err, "Error in creating blob file in os.IsExist(err)")
		io.Copy(blob, byteReader)

		return Sha1Hash{Hash: hashId}
	}

	
  LogErr(errM, "check Add()")
	
	blobPath := fmt.Sprintf("%s/%s", saveAt, objectFolder[2:])
	blobName := fmt.Sprintf("%s%s", blobPath, hashId[2:])
	blob, err := os.Create(blobName)
	LogErr(err, "Error in making blob")

	// gzipWriter := gzip.NewWriter(blob)
	// gzipWriter.Write(content)
	// gzipWriter.Close()
	io.Copy(blob, byteReader)
	
	// fmt.Printf("%s saved at %s\n", file,  hashId)

	return Sha1Hash{Hash: 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 20, Expecting-tag: 21, Received: 20
server response: 
 b'Packet-Status \r\n20 \r\n200 \r\n20 \r\n21 \r\n'
packet-sync: 19
Current Chunk to send: 
 hashId}
}

func SaveCommit(msg string) {
	const INDEX_PATH = ".yogit/stage"

	content, err := os.ReadFile(INDEX_PATH)
	LogErr(err, "Error occured, could not find file specified")

	treeHash := HasherFn(content)
	hashId := treeHa 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 7, Expecting-tag: 8, Received: 7
server response: 
 b'Packet-Status \r\n7 \r\n200 \r\n7 \r\n8 \r\n'
packet-sync: 6
Current Chunk to send: 
 sh.Hash
	objectFolder := treeHash.Hash[:2]

	saveAt := fmt.Sprintf(".yogit/objects/%s", objectFolder)
	errM := os.Mkdir(saveAt, 0777)

	if os.IsExist(errM) {
		// we want to save the commitObj inside that same folder, 
		// commitPath := fmt.Sprintf("%s/%s")
		fmt.Println("hash ->", hashId)
		fmt.Println("sharding commit", saveAt)
		fmt.Println("treeName ->", hashId[2:])
		treePath := fmt.Sprintf("%s/%s", saveAt , hashId[2:])
		tree, err := os.Create(treePath)
		LogErr(err, "Error occured in SaveCommit(), sharding")
		def 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 21, Expecting-tag: 22, Received: 21
server response: 
 b'Packet-Status \r\n21 \r\n200 \r\n21 \r\n22 \r\n'
packet-sync: 20
Current Chunk to send: 
 er tree.Close()

		byteReader := bytes.NewReader(content)
		io.Copy(tree, byteReader)
	}else {

		LogErr(errM, "check Add()")
	}
	
	treePath := fmt.Sprintf("%s/%s", saveAt, objectFolder[2:])
	treeName := fmt.Sprintf("%s%s", treePath, hashId[2:])
	fmt.Println(treeName)
	tree, err := os.Create(treeName)
	LogErr(err, "Error in making tree")
	defer tree.Close()

	byteReader := bytes.NewReader(content)
	io.Copy(tree, byteReader)
	
	// fmt.Println("hashed_content for tree is store at --- \n",hashId 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 8, Expecting-tag: 9, Received: 8
server response: 
 b'Packet-Status \r\n8 \r\n200 \r\n8 \r\n9 \r\n'
packet-sync: 7
Current Chunk to send: 
 )

	// create a hash for commit data
	commit := Commit{}
	commit.Author = "archive@persona-mp3jpeg"
	// commit.Id = 
	commit.Contact = "<archive@persona-mp3>"
	commit.Tree = treeHash
	commit.CommitMsg = msg
	commit.CommittedAt = time.Now()

	// save commit a 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 22, Expecting-tag: 23, Received: 22
server response: 
 b'Packet-Status \r\n22 \r\n200 \r\n22 \r\n23 \r\n'
packet-sync: 21
Current Chunk to send: 
 s it is 
	s := fmt.Sprintf("%v", commit)
	commitHash := HasherFn([]byte(s))
	// we basically just want to get the previous commit 
	HEAD, err := os.ReadFile(HEADER_PATH)	
	LogErr(err, "Error finding HEAD in SaveCommit()")
	_, activeBranch, _ := strings.Cut(string(HEAD), ":")

	pathTo := fmt.Sprintf(".yogit/%s", activeBranch)
	prevCommitHash, err := os.ReadFile(pathTo)
	LogErr(err, "Error finding active branch in SaveCommit()")
	
	parent := Sha1Hash {
		Hash: string(prevCommitHash),
	}

	commit.Parent = parent
	SaveCommitToObj_u(commitHash, commit)

	updateBranch(commitHash)
	commit.Id = commitHash
	updateLog(commit)
}

// this is the checkout functionality in git alias as ntimeline intead git checkout -b playground
func NewTimeLine(timeLine string) {
	pare 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 9, Expecting-tag: 10, Received: 9
server response: 
 b'Packet-Status \r\n9 \r\n200 \r\n9 \r\n10 \r\n'
packet-sync: 8
Current Chun 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 23, Expecting-tag: 24, Received: 23
server response: 
 b'Packet-Status \r\n23 \r\n200 \r\n23 \r\n24 \r\n'
packet-sync: 22
Current Chunk to send: 
 k to send: 
 nt := GetParentCommit_u()
	HEAD, err := os.OpenFile(HEADER_PATH, os.O_RDWR, 0777)
	if err != nil {
		fmt.Println("HEAD FILE NOT FOUND IN", HEADER_PATH)
		panic(err)
	}
	defer HEAD.Close()
	
	refs := fmt.Sprintf("ref:refs/heads/%s", timeLine)
	HEAD.Truncate(0)
	HEAD.Write([]byte(refs))
	newTimeLine := fmt.Sprintf("%s/%s", BRANCH_PATH, timeLine)

	
	newBranch, err := os.OpenFile(newTimeLine, os.O_CREATE | os.O_RDWR, 0777)
	LogErr(err, "Error creating new timeline in NewTimeLine()")
	defer newBranch.Close()

	newBranch.Write([]byte(parent.Hash))
	fmt.Printf("new timeline made, have fun in %s", timeLine)

}


type State struct {
	Perm string
	Sha1Id string
	File string
}
// we coud basically check for all the files in the current directory firstly
// and then if they exist, we go look for their hash and content 
// overwrite the current state with the content from the object by trunc && copying
// and for files that dont exist, we can just remake them according to Perm

func TravelTo(hash string) {
	 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 24, Expecting-tag: 25, Received: 24
server response: 
 b'Packet-Status \r\n24 \r\n200 \r\n24 \r\n25 \r\n'
packet-sync: 23
Current Chunk to send: 
 // go to obje 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 10, Expecting-tag: 11, Received: 10
server response: 
 b'Packet-Status \r\n10 \r\n200 \r\n10 \r\n11 \r\n'
packet-sync: 9
Current Chunk to send: 
 ct path to look for the first two letters of the hash passed in 
	folderName := hash[:2]
	fileName := hash[2:]
	fmt.Println(tml.Sprintf(" <yellow>  ---locating folders for commit--- </yellow>"))

	commitLocation := fmt.Sprintf("%s/%s/%s", OBJECT_PATH, folderName, fileName)
	content, err := os.ReadFile(commitLocation)
	LogErr(err, "Error in getting commit in multiverse, TravelTo()")

	// fmt.Println("here is the file state from the past")
	fmt.Println(tml.Sprintf(" <green> -> Commit found\n -> Changing directory state</green>"))
	_, treeInfo, _ := strings.Cut(string(content), "tree:")
	// fmt.Printf("\nthis is the tree Id -> %s\n", treeInfo[:40])

	treeHash := treeInfo[:40]
	// fmt.Println("locating stage area as at then...")
	 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 25, Expecting-tag: 26, Received: 25
server response: 
 b'Packet-Status \r\n25 \r\n200 \r\n25 \r\n26 \r\n'
packet-sync: 24
Current Chunk to send: 
 
	treeFolder := treeHash[:2] 
	treeName := treeHash[2:]
	treePath := fmt.Sprintf("%s/%s/%s", OBJECT_PATH, treeFolder, treeName) 

	dirSnapshot, err := os.OpenFile(treePath, os.O_RDONLY, 0)
	LogErr(err, "Error in getting directorySnapshot, TravelTo()")
	defer dirSnapshot.Close()

	// fmt. 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 11, Expecting-tag: 12, Received: 11
server response: 
 b'Packet-Status \r\n11 \r\n200 \r\n11 \r\n12 \r\n'
packet-sync: 10
Current Chunk to send: 
 Printf("\nDirectory snapshot to be read into struct -> \n%s\n", string(dirSnapshot))

	scanner := bufio.NewScanner(dirSnapshot)

	for scanner.Scan() {
		state := State{}
		line := scanner.Text()
		fmt.Println(line)
		// the file returns content stoed as 0664  {40digithash} %20sfileName
		perm, content, _ := strings.Cut(line, "{")
		fileHash, fileName, _ := strings.Cut(content, "}")

		state.Perm = perm
		state.File = strings.TrimSpace(fileName)
		state.Sha 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 26, Expecting-tag: 27, Received: 26
server response: 
 b'Packet-Status \r\n26 \r\n200 \r\n26 \r\n27 \r\n'
packet-sync: 25
Current Chunk to send: 
 1Id = fileHash
		
		// fmt.Printf("add to struct for this line %s | %s | %s->\n", perm,  fileHash, strings.TrimSpace(fileName))

		BuildState(state)
	}
}


func BuildState(state State) {
	// just regular file path build up 
	folderLocation := state.Sha1Id[:2]
	fileHash := state.Sha1Id[2:]

	pathToF := fmt.Sprintf("%s/%s/%s", OBJECT_PATH, folderLocation, fileHash)
	
	snapshot, err := os.Open(pathToF)
	LogErr(err, "Error in opening snapshot file, BuildState")
	defer snapshot.Close()


	// tame to open file in current directory
	dst, err := os.OpenFile(state.Fi 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 12, Expecting-tag: 13, Received: 12
server response: 
 b'Packet-Status \r\n12 \r\n200 \r\n12 \r\n13 \r\n'
packet-sync: 11
Current Chunk to send: 
 le, os.O_CREATE | os.O_TRUNC | os.O_RDWR, 0777)
	LogErr(err, "Error in opening file in current directory, BuildState()")
	defer dst.Close()

	io.Copy(dst, snapshot)

	// fmt.Printf("do 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 27, Expecting-tag: 28, Received: 27
server response: 
 b'Packet-Status \r\n27 \r\n200 \r\n27 \r\n28 \r\n'
packet-sync: 26
Current Chunk to send: 
 ne copying prev state -> %s-> to %s\n ", state.Sha1Id, state.File)
	fmt.Println(tml.Sprintf(" <green> -> Working directory has been updated</green>"))
}


// switchTo old branch
// check if file exists in refs/heads and then read the commit hash
// locate the hash in object store and build from there 
// goes to previous existing branch, similar with git checkout master
func SwitchTo(branch string) {
	currBranch, err:= os.ReadFile(HEADER_PATH)
	LogErr(err, "Error in reading HEADER, SwitchTo()")

	_,currBName, _ := strings.Cut(string(currBranch), "heads/")

	if currBName == branch {
		fmt.Printf("Already on current branch specified -> %s %s\n", string(currBranch), currBName)
		return
	}

	path := fmt.Sprintf("%s/%s", REFS_HEADS, branch)
	latestCommit, err := os.ReadFile(path)
	if os.IsNotExist(err) {
		// fmt.Printf("Could not fi 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 13, Expecting-tag: 14, Received: 13
server response: 
  





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 28, Expecting-tag: 29, Received: 28
server response: 
 b'Packet-Status \r\n28 \r\n200 \r\n28 \r\n29 \r\n'
packet-sync: 27
Current Chunk to send: 
 b'Packet-Status \r\n13 \r\n200 \r\n13 \r\n14 \r\n'
packet-sync: 12
Current Chunk to send: 
 nd branch specified with -> %s, try creating one first\n", branch)
		fmt.Println(tml.Sprintf(" <red> -> Could not find branch specified with -> %s, try creating one first\n</red>", branch))
		return
	}else if err != nil {
		LogErr(err, "An error occured, SwitchTo()")
	}

	// fmt.Println(tml.Sprintf(" <yellow> ---Latest commit from %s </yellow>"))

	// fmt.Printf("latest commit read from %s is %s", branch, string(latestCommit))
	TravelTo(string(latestCommit))
}

func CheckLogs() {

	tbl := table.New(os.Stdout)
	tbl.SetHeaders("hashId", "commitMessage", "commitedAt")
	tbl.SetPadding(2)

	logs, err := os.Open(".yogit/log/logs")
	LogErr(err, "Error occured in opening log file, CheckLogs()")
	defer logs.Close()

	scanner := bufio.NewScanner(logs)
	for scanner.Scan() {
		line := scanner.Text()
		// fmt.Println(line)
		_, hashId, _ := strings.Cut(line, "id:")
		id, msgSlice, _ := strings.Cut(hashId, "message:")
		_, time, _ : 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 29, Expecting-tag: 30, Received: 29
server response: 
 b'Packet-Status \r\n29 \r\n200 \r\n29 \r\n30 \r\n'
packet-sync: 28
Current Chunk to send: 
 = strings.Cut(hashId, "at:")
		msg, _, _ := strings.Cut(msgSlice, "tree")

		tbl.AddRow(stri 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 14, Expecting-tag: 15, Received: 14
server response: 
 b'Packet-Status \r\n14 \r\n200 \r\n14 \r\n15 \r\n'
packet-sync: 13
Current Chunk to send: 
 ngs.TrimSpace(id), strings.TrimSpace(msg), strings.TrimSpace(time))
	}
	
	tbl.Render()
}
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 14
 === All packets sent, closing connection ===
Streaming:  yogit/utilis.go
EOF file reached, nothing more to read
Total packets to send to server: 2

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 package yogit

import (
	"fmt"
	"log" 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 30, Expecting-tag: 31, Received: 30
server response: 
 b'Packet-Status \r\n30 \r\n200 \r\n30 \r\n31 \r\n'
packet-sync: 29
Current Chunk to send: 
 
	"os"
	"crypto/sha1"
	"strings"
	"encoding/hex"
	"github.com/liamg/tml"
)

const (
	OBJECT_PATH = ".yogit/objects"
	BRANCH_PATH = ".yogit/refs/heads"
	HEADER_PATH = ".yogit/HEADER"
)

func LogErr(err error, msg string) {
	if err != nil {
		yoErr := tml.Sprintf("Error: <red>%s</red>", msg)
		fmt.Println(yoErr)
		log.Fatal(err)
	}
}

func HasherFn(content []byte) Sha1Hash {
	hasher := sha1.New()
	hasher.Write(content)
	hashedContent := hasher.Sum(nil)

	sha1Hash := hex.EncodeToString(hashedContent)

	return Sha1Hash{Hash: sha1Hash}
}

func SaveCommitToObj_u(commitHash Sha1Hash, commit Commit) {
	folderName := commitHash.Hash[:2]
	fileName := commitHash.Hash[2:]

	savePath := fmt.Sprintf("%s/%s", OBJECT_PATH, folderName)
	filePath := fmt.Sprintf("%s/%s", savePath, fileName)

	err := os.Mkdir(savePath, 0777)
	LogErr(err, "Error in making path for commit")

	// creating commit file 
	commitFile, err := os.OpenFile(filePath, os.O_CREATE | os.O_RDWR, 0777)
	LogErr(err, "Error ma 





 == waiting on packet status f 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 31, Expecting-tag: 32, Received: 31
server response: 
 b'Packet-Status \r\n31 \r\n200 \r\n31 \r\n32 \r\n'
packet-sync: 30
Current Chunk to send: 
 rom encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 1, Expecting-tag: 2, Received: 1
server response: 
 b'Packet-Status \r\n1 \r\n200 \r\n1 \r\n2 \r\n'
packet-sync: 0
Current Chunk to send: 
 king commit file")
	defer commitFile.Close()
	commit.Id = commitHash
	// commit.Parent = Parent

	_, errW := fmt.Fprintf(commitFile, "parent:%s author:%s  commitHash:%s  commitMessage:%s tree:%s committedAt:%s\n", 
													commit.Parent.Hash, commit.Author, commit.Id.Hash, commit.CommitMsg,
													commit.Tree.Hash, commit.CommittedAt.Format("Jan 2, 1990 3:04 PM"))

	LogErr(errW, "Error writing to commit file")

}


func GetParentCommit_u() Sha1Hash{
	// we basically just want to get the previous commit 
	HEAD, err := os.ReadFile(HEADER_PATH)	
	LogErr(err, "Error finding HEAD in SaveCommit()")
	_, activeBranch, _ := strings.Cut(string(HEAD), ":")

	pathTo := fmt.Sprintf(".yogit/%s", activeBranch)
	prevCommitHash, err := os.ReadFile(pathTo)
	LogErr(err, "Error finding acti 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 32, Expecting-tag: 33, Received: 32
server response: 
 b'Packet-Status \r\n32 \r\n200 \r\n32 \r\n33 \r\n'
packet-sync: 31
Current Chunk to send: 
 ve branch in SaveCommit()")

	return Sha1Hash{Hash: string(prevCommitHash)}
}
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 1
 === All packets sent, closing connection ===
Streaming:  docs/image-4.png
EOF file reached, nothing more to read
Total packets to send to server: 27

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 32
 === All packets sent, closing connection ===
Streaming:  install.sh
EOF file reached, nothing more to read
Total packets to send to server: 1

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 #!/usr/bin/bash

echo "Installing and configuring Yogit" 
echo "Building executable..."
$(go build main.go)

windows="main.exe"
linux="main"

if [ -f "$linux" ]; then
  echo "Building for linux systems..."
  BuildLinux
else 
  echo "Building for windows system"
  curr_dir=pwd
  exec_path=$curr_dir/$linux
  echo "fatal: Build failed, please refer to docs at https://github.com/persona-mp3/yogit.git"
  echo "You can directly install the build from the repo"
fi


BuildLinux(){
  echo "Building execution Path"
  curr_dir=pwd
  exec_path=$curr_dir/$linux

  echo "Writing to bashrc..."
  config="alias yogit=$exec_path"
  echo $config

  echo $config >> ~/.bashrc
  echo "--- Confirm config was successful"
  echo "Run `yogit` to confirm or check .bashrc for $config"
}

 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 0
 === All packets sent, closing connection ===
Streaming:  .gitignore
EOF file reached, nothing more to read
Total packets to send to server: 1

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 todo
server.ts 
.yogit
change
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 0
 === All packets sent, closing connection ===
Streaming:  go.sum
EOF file reached, nothing more to read
Total packets to send to server: 2

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 github.com/aquasecurity/table v1.10.0 h1:gPWV28qp9XSlvXdT3ku8yKQoZE6II0vsmegKpW+dB08=
github.com/aquasecurity/table v1.10.0/go.mod h1:eqOmvjjB7AhXFgFqpJUEE/ietg7RrMSJZXyTN8E/wZw=
github.com/liamg/tml v0.7.0 h1:0cVok661KuQy659aFpXpem8mXUDroREuWc1p/+y7hfU=
github.com/liamg/tml v0.7.0/go.mod h1:Vuzs4Dn44Awoyd0MLl2EuJR++l1NlFqU6BJk0oxVYX4=
github.com/mattn/go-runewidth v0.0.13 h1:lTGmDsbAYt5DmK6OnoV7EuIF1wEIFAcxld6ypU4OSgU=
github.com/mattn/go-runewidth v0.0.13/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
github.com/rivo/uniseg v0.2.0 h1:S1pD9weZBuJdFmowNwbpi7BJ8TNftyUImj/0WQi72jY=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1 h1:SrN+KX8Art/Sf4HNj6Zcz06G7VEz+7w9tdXTPOZ7+l4=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/term v0.0.0-20220526004731-065cf7ba2467 h1:CBpWXWQpIRjzmkkA+M7q9Fqnwd2mZr3AFqexg8YTfoM=
golang.org/x/term v0.0.0-20220526004 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 1, Expecting-tag: 2, Received: 1
server response: 
 b'Packet-Status \r\n1 \r\n200 \r\n1 \r\n2 \r\n'
packet-sync: 0
Current Chunk to send: 
 731-065cf7ba2467/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 1
 === All packets sent, closing connection ===
Streaming:  go.mod
EOF file reached, nothing more to read
Total packets to send to server: 1

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 module yogit

go 1.24.3

require (
	github.com/aquasecurity/table v1.10.0 // indirect
	github.com/liamg/tml v0.7.0 // indirect
	github.com/mattn/go-runewidth v0.0.13 // indirect
	github.com/rivo/uniseg v0.2.0 // indirect
	golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1 // indirect
	golang.org/x/term v0.0.0-20220526004731-065cf7ba2467 // indirect
)
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 0
 === All packets sent, closing connection ===
Streaming:  yogit/yogit.go
EOF file reached, nothing more to read
Total packets to send to server: 15

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 package yogit

import (
	// "compress/gzip"
	"bufio"
	"bytes"
	"crypto/sha1"
	"encoding/hex"
	"fmt"
	"io"
	"log"
	"os"
	"strings"
	"time"

	"github.com/aquasecurity/table"
	"github.com/liamg/tml"
	// "github.com/liamg/tml"
)

type Commit struct {
	Parent Sha1Hash `json:"parent"`
	Id Sha1Hash `json:"hashId"`
	Tree Sha1Hash `json:"tree"`
	Author string `json:"author"`
	Contact string `json:"contact"`
	CommitMsg string `json:"commitMsg"`
	CommittedAt time.Time `json:"committedAt"`
}

type HashId struct {
	Id string
}

type Sha1Hash struct {
	Hash string
}

func YoGit() {
	fmt.Println("WELCOME TO YOGIT")
}

const (
	LOG_PATH = ".yogit/log/logs"
	LOG_REFS_PATH = ".yogit/log"
	REFS_HEADS = ".yogit/refs/heads"
)

func Init() {
	fmt.Println("Initialising yogit in current dir")
	// use an input package to set the global variables
	err := os.MkdirAll(".yogit", 0777)
	LogErr(err, "Error in making yogit folders")

	subFolders := []string{"objects", "log", "refs"}
	subFiles := []string{"stage", "HEADER", "GLOBALS"}
	logSu 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 1, Expecting-tag: 2, Received: 1
server response: 
 b'Packet-Status \r\n1 \r\n200 \r\n1 \r\n2 \r\n'
packet-sync: 0
Current Chunk to send: 
 bFiles := []string{"logs"}
	// logSubFolders := []string{"refs"}
	refSubFolders := []string{"heads", "tags"}

	for _, folder := range subFolders {
		path := fmt.Sprintf(".yogit/%s", folder)
		err := os.MkdirAll(path, 0777)
		LogErr(err, "Error in making subfolders")
	}

	for _, file := range subFiles {
		path := fmt.Sprintf(".yogit/%s",file)
		_, err := os.OpenFile(path, os.O_CREATE | os.O_RDWR |os.O_TRUNC,  0777)
		LogErr(err, "Error making sub file")
	}

	for _, logFile := range logSubFiles {
		path := fmt.Sprintf(".yogit/log/%s", logFile)
		_, err := os.Create(path)
		LogErr(err, "Error making logFile")
	}

	for _, ref := range refSubFolders {
		path := fmt.Sprintf(".yogit/refs/%s", ref)
		err := os.Mkdir(path, 0777)
		LogErr(err, "Error in making refSubFolders")
	}

	// create refs folder inside log
	errL := os.Mkdir(".yogit/log/refs", 0777)
	LogErr(errL, "Error making refs as sub_folder in .yogit/log/refs, Init()")

	for _, logSubFolder := range refSubFolders {
		path := fmt.Sprintf(".yogit/log/refs/%s", 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 2, Expecting-tag: 3, Received: 2
server response: 
 b'Packet-Status \r\n2 \r\n200 \r\n2 \r\n3 \r\n'
packet-sync: 1
Current Chunk to send: 
  logSubFolder)
		err := os.Mkdir(path, 0777)
		LogErr(err, "Error in making logSubFolder")

	}


	// make master branch by defualt and write it to the HEADER in .yogit
	master, err := os.Create(".yogit/refs/heads/master")
	LogErr(err, "Error in making master branch in heads")
	master.Close()

	header, err := os.OpenFile(".yogit/HEADER", os.O_WRONLY | os.O_TRUNC, 0777)
	LogErr(err, "Error in finding HEADER")
	defer header.Close()

	_, er := fmt.Fprintf(header, "ref:refs/heads/master")
	LogErr(er, "Error in making default write to header")

	fmt.Println(tml.Sprintf("<green>Done initialising</green>\n"))
}

func updateBranch(hash Sha1Hash) {
	// Find what the current HEAD is pointing at
	header, err := os.ReadFile(".yogit/HEADER")
	LogErr(err, "Error in reading HEADER")
	pointingTo := string(header)
	// expect return to be refs/heads/master or any other branch
	_, activeBranch, _:= strings.Cut(pointingTo, ":")

	pathTo := fmt.Sprintf(".yogit/%s", activeBranch)
	branch, err := os.OpenFile(pathTo, os.O_CREATE | os 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 3, Expecting-tag: 4, Received: 3
server response: 
 b'Packet-Status \r\n3 \r\n200 \r\n3 \r\n4 \r\n'
packet-sync: 2
Current Chunk to send: 
 .O_TRUNC | os.O_WRONLY, 0777)
	LogErr(err, "Error in finding the active branch")
	defer branch.Close()

	_, er := branch.Write([]byte(hash.Hash))
	LogErr(er, "Error in updating branch")

}

func updateLog(c Commit) {
	logFile, err := os.OpenFile(LOG_PATH, os.O_CREATE | os.O_RDWR | os.O_APPEND, 0777)
	LogErr(err, "Error opening log file: updateLog()")
	defer logFile.Close()

	fmtC:= fmt.Sprintf( "author:%s  id:%s  message:%s tree:%s at:%s\n", c.Author, c.Id.Hash, c.CommitMsg, c.Tree.Hash, c.CommittedAt.Format("Jan 2, 1990 3:04 PM"))
	logger := log.New(logFile, "", 0)
	logger.Println(fmtC)

	// so when we are updating a log, we want to log it to the current branch the person is also on 
	HEAD, err := os.ReadFile(HEADER_PATH)
	LogErr(err, "Error opening HEAD, See: updateLog()")
	_, currBranch, _ := strings.Cut(string(HEAD), ":")

	logBranchPath := fmt.Sprintf("%s/%s", LOG_REFS_PATH, currBranch)
	logBranch, err := os.OpenFile(logBranchPath, os.O_CREATE | os.O_APPEND | os.O_RDWR, 0777)
	LogErr(err, "Error in openi 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 4, Expecting-tag: 5, Received: 4
server response: 
 b'Packet-Status \r\n4 \r\n200 \r\n4 \r\n5 \r\n'
packet-sync: 3
Current Chunk to send: 
 ng branch path, see updateLog()")
	defer logBranch.Close()

	logBranch.Write([]byte(fmtC))
	fmt.Println(tml.Sprintf("<green> -> New commit stored\n -> Branch Updated</green>\n"))

}

func StagingArea() {
	// we need to write all current files into the staging area in .yogit/stage
	dirEntries, err := os.ReadDir(".")
	LogErr(err, "Error in reading StagingArea(), reading directory")

	stage, err := os.OpenFile(".yogit/stage", os.O_CREATE | os.O_TRUNC | os.O_RDWR, 0777)
	LogErr(err, "Error in opening stage file")
	defer stage.Close()

	for _, path := range dirEntries {
		if path.Name() == ".git" || path.Name() == ".yogit" || path.IsDir() {
			continue
		} 

		info, err := path.Info()
		LogErr(err, "Error in getting file info")

		hashId := SaveToObject(info.Name())
		_, errw := fmt.Fprintf(stage, "%04o %-20s %20s\n", info.Mode().Perm(), hashId, info.Name() )
		LogErr(errw, "Error in writing to file")
	}
	// fmt.Println("check ./yogit/stage")
	fmt.Println(tml.Sprintf("\n  <yellow>---processing index file---</yello 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 5, Expecting-tag: 6, Received: 5
server response: 
 b'Packet-Status \r\n5 \r\n200 \r\n5 \r\n6 \r\n'
packet-sync: 4
Current Chunk to send: 
 w>\n"))
	fmt.Println(tml.Sprintf("  <green>all files ready for saving</green>\n"))
}

// this function is called  in StaginArea(), it serves as hashing and saving to the object store at blob level
// so for every file, we get their hash and compressed content, and write their hash and name to the STAGE file 
// the file writing is done in StagingArea()
// the tree object is created by TreeObject() which basically does the same thing as Add() but its the index file itself
func SaveToObject(file string) Sha1Hash{
	// fmt.Println("adding all files onto the staging area")

	content, err := os.ReadFile(file)
	LogErr(err, "Error occured, could not find file specified")
	// hash the content, get the first 2 names
	hasher := sha1.New() 
	hasher.Write([]byte(content))
	hashedContent := hasher.Sum(nil)
	hashId := hex.EncodeToString(hashedContent)
	objectFolder := hashId[:2]

	byteReader := bytes.NewReader(content)

	// check if saveAt already exists, if it exisit just save the file ther
	saveAt := fmt.Sprintf(".yogit/o 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 6, Expecting-tag: 7, Received: 6
server response: 
 b'Packet-Status \r\n6 \r\n200 \r\n6 \r\n7 \r\n'
packet-sync: 5
Current Chunk to send: 
 bjects/%s", objectFolder)
	errM := os.Mkdir(saveAt, 0777)
	if os.IsExist(errM) {
		fmt.Printf("folder already exists, sharding into -> %s | %s\n", errM, hashId)

		blobPath := fmt.Sprintf("%s/%s", saveAt, hashId[2:])
		blob, err := os.Create(blobPath)
		LogErr(err, "Error in creating blob file in os.IsExist(err)")
		io.Copy(blob, byteReader)

		return Sha1Hash{Hash: hashId}
	}

	
  LogErr(errM, "check Add()")
	
	blobPath := fmt.Sprintf("%s/%s", saveAt, objectFolder[2:])
	blobName := fmt.Sprintf("%s%s", blobPath, hashId[2:])
	blob, err := os.Create(blobName)
	LogErr(err, "Error in making blob")

	// gzipWriter := gzip.NewWriter(blob)
	// gzipWriter.Write(content)
	// gzipWriter.Close()
	io.Copy(blob, byteReader)
	
	// fmt.Printf("%s saved at %s\n", file,  hashId)

	return Sha1Hash{Hash:hashId}
}

func SaveCommit(msg string) {
	const INDEX_PATH = ".yogit/stage"

	content, err := os.ReadFile(INDEX_PATH)
	LogErr(err, "Error occured, could not find file specified")

	treeHash := HasherFn(content)
	hashId := treeHa 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 7, Expecting-tag: 8, Received: 7
server response: 
 b'Packet-Status \r\n7 \r\n200 \r\n7 \r\n8 \r\n'
packet-sync: 6
Current Chunk to send: 
 sh.Hash
	objectFolder := treeHash.Hash[:2]

	saveAt := fmt.Sprintf(".yogit/objects/%s", objectFolder)
	errM := os.Mkdir(saveAt, 0777)

	if os.IsExist(errM) {
		// we want to save the commitObj inside that same folder, 
		// commitPath := fmt.Sprintf("%s/%s")
		fmt.Println("hash ->", hashId)
		fmt.Println("sharding commit", saveAt)
		fmt.Println("treeName ->", hashId[2:])
		treePath := fmt.Sprintf("%s/%s", saveAt , hashId[2:])
		tree, err := os.Create(treePath)
		LogErr(err, "Error occured in SaveCommit(), sharding")
		defer tree.Close()

		byteReader := bytes.NewReader(content)
		io.Copy(tree, byteReader)
	}else {

		LogErr(errM, "check Add()")
	}
	
	treePath := fmt.Sprintf("%s/%s", saveAt, objectFolder[2:])
	treeName := fmt.Sprintf("%s%s", treePath, hashId[2:])
	fmt.Println(treeName)
	tree, err := os.Create(treeName)
	LogErr(err, "Error in making tree")
	defer tree.Close()

	byteReader := bytes.NewReader(content)
	io.Copy(tree, byteReader)
	
	// fmt.Println("hashed_content for tree is store at --- \n",hashId 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 8, Expecting-tag: 9, Received: 8
server response: 
 b'Packet-Status \r\n8 \r\n200 \r\n8 \r\n9 \r\n'
packet-sync: 7
Current Chunk to send: 
 )

	// create a hash for commit data
	commit := Commit{}
	commit.Author = "archive@persona-mp3jpeg"
	// commit.Id = 
	commit.Contact = "<archive@persona-mp3>"
	commit.Tree = treeHash
	commit.CommitMsg = msg
	commit.CommittedAt = time.Now()

	// save commit as it is 
	s := fmt.Sprintf("%v", commit)
	commitHash := HasherFn([]byte(s))
	// we basically just want to get the previous commit 
	HEAD, err := os.ReadFile(HEADER_PATH)	
	LogErr(err, "Error finding HEAD in SaveCommit()")
	_, activeBranch, _ := strings.Cut(string(HEAD), ":")

	pathTo := fmt.Sprintf(".yogit/%s", activeBranch)
	prevCommitHash, err := os.ReadFile(pathTo)
	LogErr(err, "Error finding active branch in SaveCommit()")
	
	parent := Sha1Hash {
		Hash: string(prevCommitHash),
	}

	commit.Parent = parent
	SaveCommitToObj_u(commitHash, commit)

	updateBranch(commitHash)
	commit.Id = commitHash
	updateLog(commit)
}

// this is the checkout functionality in git alias as ntimeline intead git checkout -b playground
func NewTimeLine(timeLine string) {
	pare 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 9, Expecting-tag: 10, Received: 9
server response: 
 b'Packet-Status \r\n9 \r\n200 \r\n9 \r\n10 \r\n'
packet-sync: 8
Current Chunk to send: 
 nt := GetParentCommit_u()
	HEAD, err := os.OpenFile(HEADER_PATH, os.O_RDWR, 0777)
	if err != nil {
		fmt.Println("HEAD FILE NOT FOUND IN", HEADER_PATH)
		panic(err)
	}
	defer HEAD.Close()
	
	refs := fmt.Sprintf("ref:refs/heads/%s", timeLine)
	HEAD.Truncate(0)
	HEAD.Write([]byte(refs))
	newTimeLine := fmt.Sprintf("%s/%s", BRANCH_PATH, timeLine)

	
	newBranch, err := os.OpenFile(newTimeLine, os.O_CREATE | os.O_RDWR, 0777)
	LogErr(err, "Error creating new timeline in NewTimeLine()")
	defer newBranch.Close()

	newBranch.Write([]byte(parent.Hash))
	fmt.Printf("new timeline made, have fun in %s", timeLine)

}


type State struct {
	Perm string
	Sha1Id string
	File string
}
// we coud basically check for all the files in the current directory firstly
// and then if they exist, we go look for their hash and content 
// overwrite the current state with the content from the object by trunc && copying
// and for files that dont exist, we can just remake them according to Perm

func TravelTo(hash string) {
	// go to obje 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 10, Expecting-tag: 11, Received: 10
server response: 
 b'Packet-Status \r\n10 \r\n200 \r\n10 \r\n11 \r\n'
packet-sync: 9
Current Chunk to send: 
 ct path to look for the first two letters of the hash passed in 
	folderName := hash[:2]
	fileName := hash[2:]
	fmt.Println(tml.Sprintf(" <yellow>  ---locating folders for commit--- </yellow>"))

	commitLocation := fmt.Sprintf("%s/%s/%s", OBJECT_PATH, folderName, fileName)
	content, err := os.ReadFile(commitLocation)
	LogErr(err, "Error in getting commit in multiverse, TravelTo()")

	// fmt.Println("here is the file state from the past")
	fmt.Println(tml.Sprintf(" <green> -> Commit found\n -> Changing directory state</green>"))
	_, treeInfo, _ := strings.Cut(string(content), "tree:")
	// fmt.Printf("\nthis is the tree Id -> %s\n", treeInfo[:40])

	treeHash := treeInfo[:40]
	// fmt.Println("locating stage area as at then...")
	
	treeFolder := treeHash[:2] 
	treeName := treeHash[2:]
	treePath := fmt.Sprintf("%s/%s/%s", OBJECT_PATH, treeFolder, treeName) 

	dirSnapshot, err := os.OpenFile(treePath, os.O_RDONLY, 0)
	LogErr(err, "Error in getting directorySnapshot, TravelTo()")
	defer dirSnapshot.Close()

	// fmt. 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 11, Expecting-tag: 12, Received: 11
server response: 
 b'Packet-Status \r\n11 \r\n200 \r\n11 \r\n12 \r\n'
packet-sync: 10
Current Chunk to send: 
 Printf("\nDirectory snapshot to be read into struct -> \n%s\n", string(dirSnapshot))

	scanner := bufio.NewScanner(dirSnapshot)

	for scanner.Scan() {
		state := State{}
		line := scanner.Text()
		fmt.Println(line)
		// the file returns content stoed as 0664  {40digithash} %20sfileName
		perm, content, _ := strings.Cut(line, "{")
		fileHash, fileName, _ := strings.Cut(content, "}")

		state.Perm = perm
		state.File = strings.TrimSpace(fileName)
		state.Sha1Id = fileHash
		
		// fmt.Printf("add to struct for this line %s | %s | %s->\n", perm,  fileHash, strings.TrimSpace(fileName))

		BuildState(state)
	}
}


func BuildState(state State) {
	// just regular file path build up 
	folderLocation := state.Sha1Id[:2]
	fileHash := state.Sha1Id[2:]

	pathToF := fmt.Sprintf("%s/%s/%s", OBJECT_PATH, folderLocation, fileHash)
	
	snapshot, err := os.Open(pathToF)
	LogErr(err, "Error in opening snapshot file, BuildState")
	defer snapshot.Close()


	// tame to open file in current directory
	dst, err := os.OpenFile(state.Fi 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 12, Expecting-tag: 13, Received: 12
server response: 
 b'Packet-Status \r\n12 \r\n200 \r\n12 \r\n13 \r\n'
packet-sync: 11
Current Chunk to send: 
 le, os.O_CREATE | os.O_TRUNC | os.O_RDWR, 0777)
	LogErr(err, "Error in opening file in current directory, BuildState()")
	defer dst.Close()

	io.Copy(dst, snapshot)

	// fmt.Printf("done copying prev state -> %s-> to %s\n ", state.Sha1Id, state.File)
	fmt.Println(tml.Sprintf(" <green> -> Working directory has been updated</green>"))
}


// switchTo old branch
// check if file exists in refs/heads and then read the commit hash
// locate the hash in object store and build from there 
// goes to previous existing branch, similar with git checkout master
func SwitchTo(branch string) {
	currBranch, err:= os.ReadFile(HEADER_PATH)
	LogErr(err, "Error in reading HEADER, SwitchTo()")

	_,currBName, _ := strings.Cut(string(currBranch), "heads/")

	if currBName == branch {
		fmt.Printf("Already on current branch specified -> %s %s\n", string(currBranch), currBName)
		return
	}

	path := fmt.Sprintf("%s/%s", REFS_HEADS, branch)
	latestCommit, err := os.ReadFile(path)
	if os.IsNotExist(err) {
		// fmt.Printf("Could not fi 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 13, Expecting-tag: 14, Received: 13
server response: 
 b'Packet-Status \r\n13 \r\n200 \r\n13 \r\n14 \r\n'
packet-sync: 12
Current Chunk to send: 
 nd branch specified with -> %s, try creating one first\n", branch)
		fmt.Println(tml.Sprintf(" <red> -> Could not find branch specified with -> %s, try creating one first\n</red>", branch))
		return
	}else if err != nil {
		LogErr(err, "An error occured, SwitchTo()")
	}

	// fmt.Println(tml.Sprintf(" <yellow> ---Latest commit from %s </yellow>"))

	// fmt.Printf("latest commit read from %s is %s", branch, string(latestCommit))
	TravelTo(string(latestCommit))
}

func CheckLogs() {

	tbl := table.New(os.Stdout)
	tbl.SetHeaders("hashId", "commitMessage", "commitedAt")
	tbl.SetPadding(2)

	logs, err := os.Open(".yogit/log/logs")
	LogErr(err, "Error occured in opening log file, CheckLogs()")
	defer logs.Close()

	scanner := bufio.NewScanner(logs)
	for scanner.Scan() {
		line := scanner.Text()
		// fmt.Println(line)
		_, hashId, _ := strings.Cut(line, "id:")
		id, msgSlice, _ := strings.Cut(hashId, "message:")
		_, time, _ := strings.Cut(hashId, "at:")
		msg, _, _ := strings.Cut(msgSlice, "tree")

		tbl.AddRow(stri 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 14, Expecting-tag: 15, Received: 14
server response: 
 b'Packet-Status \r\n14 \r\n200 \r\n14 \r\n15 \r\n'
packet-sync: 13
Current Chunk to send: 
 ngs.TrimSpace(id), strings.TrimSpace(msg), strings.TrimSpace(time))
	}
	
	tbl.Render()
}
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 14
 === All packets sent, closing connection ===
Streaming:  yogit/utilis.go
EOF file reached, nothing more to read
Total packets to send to server: 2

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

Current Chunk to send: 
 package yogit

import (
	"fmt"
	"log"
	"os"
	"crypto/sha1"
	"strings"
	"encoding/hex"
	"github.com/liamg/tml"
)

const (
	OBJECT_PATH = ".yogit/objects"
	BRANCH_PATH = ".yogit/refs/heads"
	HEADER_PATH = ".yogit/HEADER"
)

func LogErr(err error, msg string) {
	if err != nil {
		yoErr := tml.Sprintf("Error: <red>%s</red>", msg)
		fmt.Println(yoErr)
		log.Fatal(err)
	}
}

func HasherFn(content []byte) Sha1Hash {
	hasher := sha1.New()
	hasher.Write(content)
	hashedContent := hasher.Sum(nil)

	sha1Hash := hex.EncodeToString(hashedContent)

	return Sha1Hash{Hash: sha1Hash}
}

func SaveCommitToObj_u(commitHash Sha1Hash, commit Commit) {
	folderName := commitHash.Hash[:2]
	fileName := commitHash.Hash[2:]

	savePath := fmt.Sprintf("%s/%s", OBJECT_PATH, folderName)
	filePath := fmt.Sprintf("%s/%s", savePath, fileName)

	err := os.Mkdir(savePath, 0777)
	LogErr(err, "Error in making path for commit")

	// creating commit file 
	commitFile, err := os.OpenFile(filePath, os.O_CREATE | os.O_RDWR, 0777)
	LogErr(err, "Error ma 





 == waiting on packet status from encoder.verify_packet_status() == 


 === verifying last packet sent === 

Current-tag: 1, Expecting-tag: 2, Received: 1
server response: 
 b'Packet-Status \r\n1 \r\n200 \r\n1 \r\n2 \r\n'
packet-sync: 0
Current Chunk to send: 
 king commit file")
	defer commitFile.Close()
	commit.Id = commitHash
	// commit.Parent = Parent

	_, errW := fmt.Fprintf(commitFile, "parent:%s author:%s  commitHash:%s  commitMessage:%s tree:%s committedAt:%s\n", 
													commit.Parent.Hash, commit.Author, commit.Id.Hash, commit.CommitMsg,
													commit.Tree.Hash, commit.CommittedAt.Format("Jan 2, 1990 3:04 PM"))

	LogErr(errW, "Error writing to commit file")

}


func GetParentCommit_u() Sha1Hash{
	// we basically just want to get the previous commit 
	HEAD, err := os.ReadFile(HEADER_PATH)	
	LogErr(err, "Error finding HEAD in SaveCommit()")
	_, activeBranch, _ := strings.Cut(string(HEAD), ":")

	pathTo := fmt.Sprintf(".yogit/%s", activeBranch)
	prevCommitHash, err := os.ReadFile(pathTo)
	LogErr(err, "Error finding active branch in SaveCommit()")

	return Sha1Hash{Hash: string(prevCommitHash)}
}
 





 == waiting on packet status from encoder.verify_packet_status() == 

perhaps, we have umm, finsihed sending packets? from server
server response: 
 b''
packet-sync: 1
 === All packets sent, closing connection ===
Streaming:  docs/image-4.png
EOF file reached, nothing more to read
Total packets to send to server: 27

 === Waiting to get Acked === 


 === packet sent, awaiting acknowledgement response === 

Server acknowledged our request, continue protocol

 === preparing packets to send === 

